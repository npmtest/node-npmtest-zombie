{"/home/travis/build/npmtest/node-npmtest-zombie/test.js":"/* istanbul instrument in package npmtest_zombie */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-zombie/lib.npmtest_zombie.js":"/* istanbul instrument in package npmtest_zombie */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_zombie = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_zombie = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-zombie/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-zombie && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_zombie */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_zombie\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_zombie.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_zombie.rollup.js'] =\n            local.assetsDict['/assets.npmtest_zombie.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_zombie.__dirname + '/lib.npmtest_zombie.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/index.js":"'use strict';\n\nvar _get = require('babel-runtime/helpers/get')['default'];\n\nvar _inherits = require('babel-runtime/helpers/inherits')['default'];\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];\n\nvar _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar _Promise = require('babel-runtime/core-js/promise')['default'];\n\nvar _Array$from = require('babel-runtime/core-js/array/from')['default'];\n\nrequire('jsdom'); // work-around for node.js import of jsdom Windows.js before jsdom living module\n\nvar assert = require('assert');\nvar Assert = require('./assert');\nvar Bluebird = require('bluebird');\nvar Tabs = require('./tabs');\nvar Console = require('./console');\nvar Cookies = require('./cookies');\nvar debug = require('debug');\nvar DOM = require('./dom');\n\nvar _require = require('events');\n\nvar EventEmitter = _require.EventEmitter;\n\nvar EventLoop = require('./eventloop');\n\nvar _require2 = require('util');\n\nvar format = _require2.format;\n\nvar Fetch = require('./fetch');\nvar File = require('fs');\nvar Mime = require('mime');\nvar ms = require('ms');\nvar Path = require('path');\nvar Pipeline = require('./pipeline');\nvar reroute = require('./reroute');\nvar Storages = require('./storage');\nvar Tough = require('tough-cookie');\nvar Cookie = Tough.Cookie;\n\nvar URL = require('url');\nvar Utils = require('jsdom/lib/jsdom/utils');\nvar fileListSymbols = require('jsdom/lib/jsdom/living/filelist-symbols');\n\n// Version number.  We get this from package.json.\nvar VERSION = require(__dirname + '/../package.json').version;\n\n// Browser options you can set when creating new browser, or on browser instance.\nvar BROWSER_OPTIONS = ['features', 'headers', 'waitDuration', 'proxy', 'referrer', 'silent', 'site', 'strictSSL', 'userAgent', 'language', 'runScripts', 'localAddress'];\n\n// These features are set on/off by default.\n// Note that default values are actually prescribed where they are used,\n// by calling hasFeature with name and default\nvar DEFAULT_FEATURES = 'scripts no-css no-img iframe';\n\nvar MOUSE_EVENT_NAMES = ['mousedown', 'mousemove', 'mouseup'];\n\n// Use the browser to open up new windows and load documents.\n//\n// The browser maintains state for cookies and local storage.\n\nvar Browser = (function (_EventEmitter) {\n  _inherits(Browser, _EventEmitter);\n\n  function Browser() {\n    var _this = this;\n\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, Browser);\n\n    _get(Object.getPrototypeOf(Browser.prototype), 'constructor', this).call(this);\n    // Used for assertions\n    this.assert = new Assert(this);\n    this.cookies = new Cookies();\n    // Shared by all windows.\n    this.console = new Console(this);\n    // Start with no this referrer.\n    this.referrer = null;\n    // Open tabs.\n    this.tabs = new Tabs(this);\n    // New pipeline for this browser.\n    this.pipeline = new Pipeline(this);\n\n    // The browser event loop.\n    this._eventLoop = new EventLoop(this);\n\n    // Returns all errors reported while loading this window.\n    this.errors = [];\n\n    this._storages = new Storages();\n\n    // The window that is currently in scope, some JS functions need this, e.g.\n    // when closing a window, you need to determine whether caller (window in\n    // scope) is same as window.opener\n    this._windowInScope = null;\n\n    this._debug = Browser._debug;\n\n    // Message written to window.console.  Level is log, info, error, etc.\n    //\n    // All output goes to stdout, except when browser.silent = true and output\n    // only shown when debugging (DEBUG=zombie).\n    this.on('console', function (level, message) {\n      if (_this.silent) _this._debug('>> ' + message);else console.log(message);\n    }).on('log', function () {\n      // Message written to browser.log.\n      _this._debug(format.apply(undefined, arguments));\n    });\n\n    // Logging resources\n    this.on('request', function (request) {\n      return request;\n    }).on('response', function (request, response) {\n      _this._debug('%s %s => %s', request.method, response.url, response.status);\n    }).on('redirect', function (request, response) {\n      _this._debug('%s %s => %s %s', request.method, request.url, response.status, response.headers.get('Location'));\n    }).on('loaded', function (document) {\n      _this._debug('Loaded document %s', document.location.href);\n    }).on('xhr', function (eventName, url) {\n      _this._debug('XHR %s %s', eventName, url);\n    });\n\n    // Logging windows/tabs/navigation\n    this.on('opened', function (window) {\n      _this._debug('Opened window %s %s', window.location.href, window.name || '');\n    }).on('closed', function (window) {\n      _this._debug('Closed window %s %s', window.location.href, window.name || '');\n    });\n\n    // Switching tabs/windows fires blur/focus event on active window/element\n    this.on('active', function (window) {\n      // Window becomes inactive\n      var winFocus = window.document.createEvent('HTMLEvents');\n      winFocus.initEvent('focus', false, false);\n      window.dispatchEvent(winFocus);\n\n      if (window.document.activeElement) {\n        var elemFocus = window.document.createEvent('HTMLEvents');\n        elemFocus.initEvent('focus', false, false);\n        window.document.activeElement.dispatchEvent(elemFocus);\n      }\n    }).on('inactive', function (window) {\n      // Window becomes inactive\n      if (window.document.activeElement) {\n        var elemBlur = window.document.createEvent('HTMLEvents');\n        elemBlur.initEvent('blur', false, false);\n        window.document.activeElement.dispatchEvent(elemBlur);\n      }\n      var winBlur = window.document.createEvent('HTMLEvents');\n      winBlur.initEvent('blur', false, false);\n      window.dispatchEvent(winBlur);\n    });\n\n    // Logging navigation\n    this.on('link', function (url) {\n      _this._debug('Follow link to %s', url);\n    }).on('submit', function (url) {\n      _this._debug('Submit form to %s', url);\n    });\n\n    // Logging event loop\n    this._eventLoop.on('setTimeout', function (fn, delay) {\n      _this._debug('Fired setTimeout after %dms delay', delay);\n      _this.emit('setTimeout', fn, delay);\n    }).on('setInterval', function (fn, interval) {\n      _this._debug('Fired setInterval every %dms', interval);\n      _this.emit('setInterval', fn, interval);\n    }).on('serverEvent', function () {\n      _this._debug('Server initiated event');\n      _this.emit('serverEvent');\n    }).on('idle', function (timedOut) {\n      if (timedOut) _this._debug('Event loop timed out');else _this._debug('Event loop is empty');\n      _this.emit('idle');\n    }).on('error', function (error) {\n      _this.emit('error', error);\n    });\n\n    // Make sure we don't blow up Node when we get a JS error, but dump error to console.  Also, catch any errors\n    // reported while processing resources/JavaScript.\n    this.on('error', function (error) {\n      _this.errors.push(error);\n      _this._debug(error.stack);\n    });\n\n    // Sets the browser options.\n    options = options || {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _getIterator(BROWSER_OPTIONS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _name = _step.value;\n\n        this[_name] = options.hasOwnProperty(_name) ? options[_name] : Browser[_name] || null;\n      }\n\n      // Last, run all extensions in order.\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator['return']) {\n          _iterator['return']();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = _getIterator(Browser._extensions), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var extension = _step2.value;\n\n        extension(this);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n          _iterator2['return']();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  // Returns true if the given feature is enabled.\n  //\n  // If the feature is listed, then it is enabled.  If the feature is listed\n  // with \"no-\" prefix, then it is disabled.  If the feature is missing, return\n  // the default value.\n\n  _createClass(Browser, [{\n    key: 'hasFeature',\n    value: function hasFeature(name) {\n      var defaultValue = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n      var features = (this.features || '').split(/\\s+/);\n      return ~features.indexOf(name) ? true : ~features.indexOf('no-' + name) ? false : defaultValue;\n    }\n\n    // Return a new browser with a snapshot of this browser's state.\n    // Any changes to the forked browser's state do not affect this browser.\n  }, {\n    key: 'fork',\n    value: function fork() {\n      throw new Error('Not implemented');\n    }\n\n    // Windows\n    // -------\n\n    // Returns the currently open window\n  }, {\n    key: 'open',\n\n    // Open new browser window.\n    value: function open() {\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var url = _ref.url;\n      var name = _ref.name;\n      var referrer = _ref.referrer;\n\n      return this.tabs.open({ url: url, name: name, referrer: referrer });\n    }\n\n    // browser.error => Error\n    //\n    // Returns the last error reported while loading this window.\n  }, {\n    key: 'wait',\n\n    // Events\n    // ------\n\n    // Waits for the browser to complete loading resources and processing JavaScript events.\n    //\n    // Accepts two parameters, both optional:\n    // options   - Options that determine how long to wait (see below)\n    // callback  - Called with error or null and browser\n    //\n    // To determine how long to wait:\n    // duration  - Do not wait more than this duration (milliseconds or string of\n    //             the form \"5s\"). Defaults to \"5s\" (see Browser.waitDuration).\n    // element   - Stop when this element(s) appear in the DOM.\n    // function  - Stop when function returns true; this function is called with\n    //             the active window and expected time to the next event (0 to\n    //             Infinity).\n    //\n    // As a convenience you can also pass the duration directly.\n    //\n    // Without a callback, this method returns a promise.\n    value: function wait(options, callback) {\n      assert(this.window, new Error('No window open'));\n      if (arguments.length === 1 && typeof options === 'function') {\n        ;\n        var _ref2 = [options, null];\n        callback = _ref2[0];\n        options = _ref2[1];\n      }assert(!callback || typeof callback === 'function', 'Second argument expected to be a callback function or null');\n\n      // Support all sort of shortcuts for options. Unofficial.\n      var duration = typeof options === 'number' ? options : typeof options === 'string' ? options : options && options.duration || this.waitDuration || '5s';\n      // Support 500 (ms) as well as \"5s\"\n      var waitDuration = ms(duration.toString());\n\n      function completionFromElement(element) {\n        return function (window) {\n          return !!window.document.querySelector(element);\n        };\n      }\n\n      var completionFunction = typeof options === 'function' ? options : options && options.element ? completionFromElement(options.element) : options && options['function'];\n\n      var _eventLoop = this._eventLoop;\n\n      if (callback) _eventLoop.wait(waitDuration, completionFunction, callback);else return Bluebird.promisify(_eventLoop.wait.bind(_eventLoop))(waitDuration, completionFunction);\n    }\n\n    // Waits for the browser to get a single event from any EventSource,\n    // then completes loading resources and processing JavaScript events.\n    //\n    // Accepts an optional callback which is called with error or nothing\n    //\n    // Without a callback, this method returns a promise.\n  }, {\n    key: 'waitForServer',\n    value: function waitForServer(options, callback) {\n      var _this2 = this;\n\n      assert(this.window, new Error('No window open'));\n      if (arguments.length === 1 && typeof options === 'function') {\n        ;\n\n        var _ref3 = [options, null];\n        callback = _ref3[0];\n        options = _ref3[1];\n      }if (callback) {\n        this._eventLoop.once('serverEvent', function () {\n          _this2.wait(options, callback);\n        });\n        return null;\n      }\n\n      return new _Promise(function (resolve) {\n        _this2._eventLoop.once('serverEvent', function () {\n          resolve(_this2.wait(options, null));\n        });\n      });\n    }\n\n    // Various methods use this with a callback, or return a lazy promise (e.g.\n    // visit, click, fire)\n  }, {\n    key: '_wait',\n    value: function _wait(options, callback) {\n      var _this3 = this;\n\n      if (callback) {\n        this.wait(options, callback);\n        return null;\n      }\n\n      var promise = null;\n      var lazyResolve = function lazyResolve() {\n        if (!promise) promise = _this3.wait(options, null);\n        return promise;\n      };\n      // Returns equivalent of a promise that only starts evaluating when you\n      // call then() or catch() on it.\n      return {\n        then: function then(resolved, rejected) {\n          return lazyResolve().then(resolved, rejected);\n        },\n        'catch': function _catch(rejected) {\n          return lazyResolve().then(null, rejected);\n        }\n      };\n    }\n\n    // Fire a DOM event.  You can use this to simulate a DOM event, e.g. clicking\n    // a link.  These events will bubble up and can be cancelled.  Like `wait`\n    // this method takes an optional callback and returns a promise.\n    //\n    // name - Even name (e.g `click`)\n    // target - Target element (e.g a link)\n    // callback - Called with error or nothing\n    //\n    // If called without callback, returns a promise\n  }, {\n    key: 'fire',\n    value: function fire(selector, eventName, callback) {\n      assert(this.window, 'No window open');\n      var target = this.query(selector);\n      assert(target && target.dispatchEvent, 'No target element (note: call with selector/element, event name and callback)');\n\n      var eventType = ~MOUSE_EVENT_NAMES.indexOf(eventName) ? 'MouseEvents' : 'HTMLEvents';\n      var event = this.document.createEvent(eventType);\n      event.initEvent(eventName, true, true);\n      target.dispatchEvent(event);\n      return this._wait(null, callback);\n    }\n\n    // Click on the element and returns a promise.\n    //\n    // selector - Element or CSS selector\n    // callback - Called with error or nothing\n    //\n    // If called without callback, returns a promise\n  }, {\n    key: 'click',\n    value: function click(selector, callback) {\n      return this.fire(selector, 'click', callback);\n    }\n\n    // Dispatch asynchronously.  Returns true if preventDefault was set.\n  }, {\n    key: 'dispatchEvent',\n    value: function dispatchEvent(selector, event) {\n      assert(this.window, 'No window open');\n      var target = this.query(selector);\n      return target.dispatchEvent(event);\n    }\n\n    // Accessors\n    // ---------\n\n    // browser.queryAll(selector, context?) => Array\n    //\n    // Evaluates the CSS selector against the document (or context node) and return array of nodes.\n    // (Unlike `document.querySelectorAll` that returns a node list).\n  }, {\n    key: 'queryAll',\n    value: function queryAll() {\n      var selector = arguments.length <= 0 || arguments[0] === undefined ? 'html' : arguments[0];\n      var context = arguments.length <= 1 || arguments[1] === undefined ? this.document : arguments[1];\n\n      assert(this.document && this.document.documentElement, 'No open window with an HTML document');\n\n      if (Array.isArray(selector)) return selector;\n      if (selector instanceof DOM.Element) return [selector];\n      if (selector) {\n        var elements = context.querySelectorAll(selector);\n        return _Array$from(elements);\n      } else return [];\n    }\n\n    // browser.query(selector, context?) => Element\n    //\n    // Evaluates the CSS selector against the document (or context node) and return an element.\n  }, {\n    key: 'query',\n    value: function query() {\n      var selector = arguments.length <= 0 || arguments[0] === undefined ? 'html' : arguments[0];\n      var context = arguments.length <= 1 || arguments[1] === undefined ? this.document : arguments[1];\n\n      assert(this.document && this.document.documentElement, 'No open window with an HTML document');\n\n      if (selector instanceof DOM.Element) return selector;\n      return selector ? context.querySelector(selector) : context;\n    }\n\n    // WebKit offers this.\n  }, {\n    key: '$$',\n    value: function $$(selector, context) {\n      return this.query(selector, context);\n    }\n\n    // browser.querySelector(selector) => Element\n    //\n    // Select a single element (first match) and return it.\n    //\n    // selector - CSS selector\n    //\n    // Returns an Element or null\n  }, {\n    key: 'querySelector',\n    value: function querySelector(selector) {\n      assert(this.document && this.document.documentElement, 'No open window with an HTML document');\n      return this.document.querySelector(selector);\n    }\n\n    // browser.querySelectorAll(selector) => NodeList\n    //\n    // Select multiple elements and return a static node list.\n    //\n    // selector - CSS selector\n    //\n    // Returns a NodeList or null\n  }, {\n    key: 'querySelectorAll',\n    value: function querySelectorAll(selector) {\n      assert(this.document && this.document.documentElement, 'No open window with an HTML document');\n      return this.document.querySelectorAll(selector);\n    }\n\n    // browser.text(selector, context?) => String\n    //\n    // Returns the text contents of the selected elements.\n    //\n    // selector - CSS selector (if missing, entire document)\n    // context - Context element (if missing, uses document)\n    //\n    // Returns a string\n  }, {\n    key: 'text',\n    value: function text() {\n      var selector = arguments.length <= 0 || arguments[0] === undefined ? 'html' : arguments[0];\n      var context = arguments.length <= 1 || arguments[1] === undefined ? this.document : arguments[1];\n\n      assert(this.document, 'No window open');\n\n      if (this.document.documentElement) return this.queryAll(selector, context).map(function (elem) {\n        return elem.textContent;\n      }).join('').trim().replace(/\\s+/g, ' ');else return this.source ? this.source.toString : '';\n    }\n\n    // browser.html(selector?, context?) => String\n    //\n    // Returns the HTML contents of the selected elements.\n    //\n    // selector - CSS selector (if missing, entire document)\n    // context - Context element (if missing, uses document)\n    //\n    // Returns a string\n  }, {\n    key: 'html',\n    value: function html() {\n      var selector = arguments.length <= 0 || arguments[0] === undefined ? 'html' : arguments[0];\n      var context = arguments.length <= 1 || arguments[1] === undefined ? this.document : arguments[1];\n\n      assert(this.document, 'No window open');\n\n      if (this.document.documentElement) return this.queryAll(selector, context).map(function (elem) {\n        return elem.outerHTML.trim();\n      }).join('');else return this.source ? this.source.toString : '';\n    }\n\n    // browser.xpath(expression, context?) => XPathResult\n    //\n    // Evaluates the XPath expression against the document (or context node) and return the XPath result.  Shortcut for\n    // `document.evaluate`.\n  }, {\n    key: 'xpath',\n    value: function xpath(expression) {\n      var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n      return this.document.evaluate(expression, context || this.document.documentElement, null, DOM.XPathResult.ANY_TYPE);\n    }\n\n    // browser.document => Document\n    //\n    // Returns the main window's document. Only valid after opening a document (see `browser.open`).\n  }, {\n    key: 'destroy',\n\n    // Close all windows, clean state, etc.  This doesn't do anything the garbage\n    // collector doesn't already do, so you don't need to call this.\n    //\n    // But because it destroys the browser state, it's quite useful for detecting\n    // weird behavior bugs, e.g. an event loop that keeps running.  That's why\n    // the test suite uses this method.\n    value: function destroy() {\n      if (this.tabs) {\n        this.tabs.closeAll();\n        this.tabs = null;\n      }\n    }\n\n    // Navigation\n    // ----------\n\n    // browser.visit(url, callback?)\n    //\n    // Loads document from the specified URL, processes events and calls the callback, or returns a promise.\n  }, {\n    key: 'visit',\n    value: function visit(url, options, callback) {\n      if (arguments.length < 3 && typeof options === 'function') {\n        ;\n\n        var _ref4 = [{}, options];\n        options = _ref4[0];\n        callback = _ref4[1];\n      }var site = /^(https?:|file:)/i.test(this.site) ? this.site : 'http://' + (this.site || 'localhost') + '/';\n      url = Utils.resolveHref(site, URL.format(url));\n\n      if (this.window) this.tabs.close(this.window);\n      this.errors = [];\n      this.tabs.open({ url: url, referrer: this.referrer });\n      return this._wait(options, callback);\n    }\n\n    // browser.load(html, callback)\n    //\n    // Loads the HTML, processes events and calls the callback.\n    //\n    // Without a callback, returns a promise.\n  }, {\n    key: 'load',\n    value: function load(html, callback) {\n      if (this.window) this.tabs.close(this.window);\n      this.errors = [];\n      this.tabs.open({ html: html });\n      return this._wait(null, callback);\n    }\n\n    // browser.location => Location\n    //\n    // Return the location of the current document (same as `window.location`).\n  }, {\n    key: 'link',\n\n    // browser.link(selector) : Element\n    //\n    // Finds and returns a link by its text content or selector.\n    value: function link(selector) {\n      assert(this.document && this.document.documentElement, 'No open window with an HTML document');\n      // If the link has already been queried, return itself\n      if (selector instanceof DOM.Element) return selector;\n\n      try {\n        var link = this.querySelector(selector);\n        if (link && link.tagName === 'A') return link;\n      } catch (error) {\n        /* eslint no-empty:0 */\n      }\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = _getIterator(_Array$from(this.querySelectorAll('body a'))), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var elem = _step3.value;\n\n          if (elem.textContent.trim() === selector) return elem;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3['return']) {\n            _iterator3['return']();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    // browser.clickLink(selector, callback)\n    //\n    // Clicks on a link. Clicking on a link can trigger other events, load new page, etc: use a callback to be notified of\n    // completion.  Finds link by text content or selector.\n    //\n    // selector - CSS selector or link text\n    // callback - Called with two arguments: error and browser\n  }, {\n    key: 'clickLink',\n    value: function clickLink(selector, callback) {\n      var link = this.link(selector);\n      assert(link, 'No link matching \\'' + selector + '\\'');\n      return this.click(link, callback);\n    }\n\n    // Return the history object.\n  }, {\n    key: 'back',\n\n    // Navigate back in history.\n    value: function back(callback) {\n      this.window.history.back();\n      return this._wait(null, callback);\n    }\n\n    // Reloads current page.\n  }, {\n    key: 'reload',\n    value: function reload(callback) {\n      this.window.location.reload();\n      return this._wait(null, callback);\n    }\n\n    // browser.saveHistory() => String\n    //\n    // Save history to a text string.  You can use this to load the data later on using `browser.loadHistory`.\n  }, {\n    key: 'saveHistory',\n    value: function saveHistory() {\n      return this.window.history.save();\n    }\n\n    // browser.loadHistory(String)\n    //\n    // Load history from a text string (e.g. previously created using `browser.saveHistory`.\n  }, {\n    key: 'loadHistory',\n    value: function loadHistory(serialized) {\n      this.window.history.load(serialized);\n    }\n\n    // Forms\n    // -----\n\n    // browser.field(selector) : Element\n    //\n    // Find and return an input field (`INPUT`, `TEXTAREA` or `SELECT`) based on a CSS selector, field name (its `name`\n    // attribute) or the text value of a label associated with that field (case sensitive, but ignores leading/trailing\n    // spaces).\n  }, {\n    key: 'field',\n    value: function field(selector) {\n      assert(this.document && this.document.documentElement, 'No open window with an HTML document');\n      // If the field has already been queried, return itself\n      if (selector instanceof DOM.Element) return selector;\n\n      try {\n        // Try more specific selector first.\n        var field = this.query(selector);\n        if (field && (field.tagName === 'INPUT' || field.tagName === 'TEXTAREA' || field.tagName === 'SELECT')) return field;\n      } catch (error) {}\n      // Invalid selector, but may be valid field name\n\n      // Use field name (case sensitive).\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = _getIterator(this.queryAll('input[name],textarea[name],select[name]')), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var elem = _step4.value;\n\n          if (elem.getAttribute('name') === selector) return elem;\n        }\n\n        // Try finding field from label.\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4['return']) {\n            _iterator4['return']();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = _getIterator(this.queryAll('label')), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var label = _step5.value;\n\n          if (label.textContent.trim() === selector) {\n            // nLabel can either reference field or enclose it\n            var forAttr = label.getAttribute('for');\n            return forAttr ? this.document.getElementById(forAttr) : label.querySelector('input,textarea,select');\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5['return']) {\n            _iterator5['return']();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    // browser.focus(selector) : Element\n    //\n    // Turns focus to the selected input field.  Shortcut for calling `field(selector).focus()`.\n  }, {\n    key: 'focus',\n    value: function focus(selector) {\n      var field = this.field(selector) || this.query(selector);\n      assert(field, 'No form field matching \\'' + selector + '\\'');\n      field.focus();\n      return this;\n    }\n\n    // browser.fill(selector, value) => this\n    //\n    // Fill in a field: input field or text area.\n    //\n    // selector - CSS selector, field name or text of the field label\n    // value - Field value\n    //\n    // Returns this.\n  }, {\n    key: 'fill',\n    value: function fill(selector, value) {\n      var field = this.field(selector);\n      assert(field && (field.tagName === 'TEXTAREA' || field.tagName === 'INPUT'), 'No INPUT matching \\'' + selector + '\\'');\n      assert(!field.disabled, 'This INPUT field is disabled');\n      assert(!field.readonly, 'This INPUT field is readonly');\n\n      // Switch focus to field, change value and emit the input event (HTML5)\n      field.focus();\n      field.value = value;\n      this.fire(field, 'input', false);\n      // Switch focus out of field, if value changed, this will emit change event\n      field.blur();\n      return this;\n    }\n  }, {\n    key: '_setCheckbox',\n    value: function _setCheckbox(selector, value) {\n      var field = this.field(selector);\n      assert(field && field.tagName === 'INPUT' && field.type === 'checkbox', 'No checkbox INPUT matching \\'' + selector + '\\'');\n      assert(!field.disabled, 'This INPUT field is disabled');\n      assert(!field.readonly, 'This INPUT field is readonly');\n\n      if (field.checked ^ value) field.click();\n      return this;\n    }\n\n    // browser.check(selector) => this\n    //\n    // Checks a checkbox.\n    //\n    // selector - CSS selector, field name or text of the field label\n    //\n    // Returns this.\n  }, {\n    key: 'check',\n    value: function check(selector) {\n      return this._setCheckbox(selector, true);\n    }\n\n    // browser.uncheck(selector) => this\n    //\n    // Unchecks a checkbox.\n    //\n    // selector - CSS selector, field name or text of the field label\n    //\n    // Returns this.\n  }, {\n    key: 'uncheck',\n    value: function uncheck(selector) {\n      return this._setCheckbox(selector, false);\n    }\n\n    // browser.choose(selector) => this\n    //\n    // Selects a radio box option.\n    //\n    // selector - CSS selector, field value or text of the field label\n    //\n    // Returns this.\n  }, {\n    key: 'choose',\n    value: function choose(selector) {\n      var field = this.field(selector) || this.field('input[type=radio][value=\\'' + escape(selector) + '\\']');\n      assert(field && field.tagName === 'INPUT' && field.type === 'radio', 'No radio INPUT matching \\'' + selector + '\\'');\n\n      field.click();\n      return this;\n    }\n  }, {\n    key: '_findOption',\n    value: function _findOption(selector, value) {\n      var field = this.field(selector);\n      assert(field && field.tagName === 'SELECT', 'No SELECT matching \\'' + selector + '\\'');\n      assert(!field.disabled, 'This SELECT field is disabled');\n      assert(!field.readonly, 'This SELECT field is readonly');\n\n      var options = _Array$from(field.options);\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = _getIterator(options), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var option = _step6.value;\n\n          if (option.value === value) return option;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6['return']) {\n            _iterator6['return']();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = _getIterator(options), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var option = _step7.value;\n\n          if (option.label === value) return option;\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7['return']) {\n            _iterator7['return']();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = _getIterator(options), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var option = _step8.value;\n\n          if (option.textContent.trim() === value) return option;\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8['return']) {\n            _iterator8['return']();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      throw new Error('No OPTION \\'' + value + '\\'');\n    }\n\n    // browser.select(selector, value) => this\n    //\n    // Selects an option.\n    //\n    // selector - CSS selector, field name or text of the field label\n    // value - Value (or label) or option to select\n    //\n    // Returns this.\n  }, {\n    key: 'select',\n    value: function select(selector, value) {\n      var option = this._findOption(selector, value);\n      this.selectOption(option);\n      return this;\n    }\n\n    // browser.selectOption(option) => this\n    //\n    // Selects an option.\n    //\n    // option - option to select\n    //\n    // Returns this.\n  }, {\n    key: 'selectOption',\n    value: function selectOption(selector) {\n      var option = this.query(selector);\n      if (option && !option.selected) {\n        var select = this.xpath('./ancestor::select', option).iterateNext();\n        option.selected = true;\n        select.focus();\n        this.fire(select, 'change', false);\n      }\n      return this;\n    }\n\n    // browser.unselect(selector, value) => this\n    //\n    // Unselects an option.\n    //\n    // selector - CSS selector, field name or text of the field label\n    // value - Value (or label) or option to unselect\n    //\n    // Returns this.\n  }, {\n    key: 'unselect',\n    value: function unselect(selector, value) {\n      var option = this._findOption(selector, value);\n      this.unselectOption(option);\n      return this;\n    }\n\n    // browser.unselectOption(option) => this\n    //\n    // Unselects an option.\n    //\n    // selector - selector or option to unselect\n    //\n    // Returns this.\n  }, {\n    key: 'unselectOption',\n    value: function unselectOption(selector) {\n      var option = this.query(selector);\n      if (option && option.selected) {\n        var select = this.xpath('./ancestor::select', option).iterateNext();\n        assert(select.multiple, 'Cannot unselect in single select');\n        option.selected = false;\n        select.focus();\n        this.fire(select, 'change', false);\n      }\n      return this;\n    }\n\n    // browser.attach(selector, filename) => this\n    //\n    // Attaches a file to the specified input field.  The second argument is the file name.\n    //\n    // Returns this.\n  }, {\n    key: 'attach',\n    value: function attach(selector, filename) {\n      var field = this.field(selector);\n      assert(field && field.tagName === 'INPUT' && field.type === 'file', 'No file INPUT matching \\'' + selector + '\\'');\n\n      if (filename) {\n        var stat = File.statSync(filename);\n        var file = new this.window.File();\n        file.name = Path.basename(filename);\n        file.type = Mime.lookup(filename);\n        file.size = stat.size;\n\n        field.value = filename;\n        var oldFiles = field.files;\n        if (typeof oldFiles !== 'array') {\n          // JSDOM does not support an API to mock a list of files, and the default\n          // type of the 'files' attribute is a FileList object.\n          Object.defineProperty(field, 'files', {\n            value: []\n          });\n        }\n        field.files.push(file);\n      }\n      field.focus();\n      this.fire(field, 'change', false);\n      return this;\n    }\n\n    // browser.button(selector) : Element\n    //\n    // Finds a button using CSS selector, button name or button text (`BUTTON` or `INPUT` element).\n    //\n    // selector - CSS selector, button name or text of BUTTON element\n  }, {\n    key: 'button',\n    value: function button(selector) {\n      assert(this.document && this.document.documentElement, 'No open window with an HTML document');\n      // If the button has already been queried, return itself\n      if (selector instanceof DOM.Element) return selector;\n\n      try {\n        var button = this.querySelector(selector);\n        if (button && (button.tagName === 'BUTTON' || button.tagName === 'INPUT')) return button;\n      } catch (error) {}\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = _getIterator(_Array$from(this.querySelectorAll('button'))), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var elem = _step9.value;\n\n          if (elem.textContent.trim() === selector) return elem;\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9['return']) {\n            _iterator9['return']();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      var inputs = _Array$from(this.querySelectorAll('input[type=submit],input[type=button],input[type=reset],button'));\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = _getIterator(inputs), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var input = _step10.value;\n\n          if (input.name === selector) return input;\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10['return']) {\n            _iterator10['return']();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n      var _iteratorError11 = undefined;\n\n      try {\n        for (var _iterator11 = _getIterator(inputs), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n          var input = _step11.value;\n\n          if (input.value === selector) return input;\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11['return']) {\n            _iterator11['return']();\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    // browser.pressButton(selector, callback)\n    //\n    // Press a button (button element or input of type `submit`).  Typically this will submit the form.  Use the callback\n    // to wait for the from submission, page to load and all events run their course.\n    //\n    // selector - CSS selector, button name or text of BUTTON element\n    // callback - Called with two arguments: null and browser\n  }, {\n    key: 'pressButton',\n    value: function pressButton(selector, callback) {\n      var button = this.button(selector);\n      assert(button, 'No BUTTON \\'' + selector + '\\'');\n      assert(!button.disabled, 'This button is disabled');\n      button.focus();\n      return this.fire(button, 'click', callback);\n    }\n\n    // -- Cookies --\n\n    // Returns cookie that best matches the identifier.\n    //\n    // identifier - Identifies which cookie to return\n    // allProperties - If true, return all cookie properties, other just the value\n    //\n    // Identifier is either the cookie name, in which case the cookie domain is\n    // determined from the currently open Web page, and the cookie path is \"/\".\n    //\n    // Or the identifier can be an object specifying:\n    // name   - The cookie name\n    // domain - The cookie domain (defaults to hostname of currently open page)\n    // path   - The cookie path (defaults to \"/\")\n    //\n    // Returns cookie value, or cookie object (see setCookie).\n  }, {\n    key: 'getCookie',\n    value: function getCookie(identifier, allProperties) {\n      identifier = this._cookieIdentifier(identifier);\n      assert(identifier.name, 'Missing cookie name');\n      assert(identifier.domain, 'No domain specified and no open page');\n\n      var cookie = this.cookies.select(identifier)[0];\n      return cookie ? allProperties ? this._cookieProperties(cookie) : cookie.value : null;\n    }\n\n    // Deletes cookie that best matches the identifier.\n    //\n    // identifier - Identifies which cookie to return\n    //\n    // Identifier is either the cookie name, in which case the cookie domain is\n    // determined from the currently open Web page, and the cookie path is \"/\".\n    //\n    // Or the identifier can be an object specifying:\n    // name   - The cookie name\n    // domain - The cookie domain (defaults to hostname of currently open page)\n    // path   - The cookie path (defaults to \"/\")\n    //\n    // Returns true if cookie delete.\n  }, {\n    key: 'deleteCookie',\n    value: function deleteCookie(identifier) {\n      identifier = this._cookieIdentifier(identifier);\n      assert(identifier.name, 'Missing cookie name');\n      assert(identifier.domain, 'No domain specified and no open page');\n\n      var cookie = this.cookies.select(identifier)[0];\n      if (cookie) this.cookies['delete'](cookie);\n      return !!cookie;\n    }\n\n    // Sets a cookie.\n    //\n    // You can call this function with two arguments to set a session cookie: the\n    // cookie value and cookie name.  The domain is determined from the current\n    // page URL, and the path is always \"/\".\n    //\n    // Or you can call it with a single argument, with all cookie options:\n    // name     - Name of the cookie\n    // value    - Value of the cookie\n    // domain   - The cookie domain (e.g example.com, .example.com)\n    // path     - The cookie path\n    // expires  - Time when cookie expires\n    // maxAge   - How long before cookie expires\n    // secure   - True for HTTPS only cookie\n    // httpOnly - True if cookie not accessible from JS\n  }, {\n    key: 'setCookie',\n    value: function setCookie(nameOrOptions, value) {\n      var domain = this.location && this.location.hostname;\n      if (typeof nameOrOptions === 'string') this.cookies.set({\n        name: nameOrOptions,\n        value: value || '',\n        domain: domain,\n        path: '/',\n        secure: false,\n        httpOnly: false\n      });else {\n        assert(nameOrOptions.name, 'Missing cookie name');\n        this.cookies.set({\n          name: nameOrOptions.name,\n          value: nameOrOptions.value || value || '',\n          domain: nameOrOptions.domain || domain,\n          path: nameOrOptions.path || '/',\n          secure: !!nameOrOptions.secure,\n          httpOnly: !!nameOrOptions.httpOnly,\n          expires: nameOrOptions.expires,\n          'max-age': nameOrOptions['max-age']\n        });\n      }\n    }\n\n    // Deletes all cookies.\n  }, {\n    key: 'deleteCookies',\n    value: function deleteCookies() {\n      this.cookies.deleteAll();\n    }\n\n    // Save cookies to a text string.  You can use this to load them back\n    // later on using `Browser.loadCookies`.\n  }, {\n    key: 'saveCookies',\n    value: function saveCookies() {\n      var serialized = ['# Saved on ' + new Date().toISOString()];\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = _getIterator(this.cookies.sort(Tough.cookieCompare)), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var cookie = _step12.value;\n\n          serialized.push(cookie.toString());\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12['return']) {\n            _iterator12['return']();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n\n      return serialized.join('\\n') + '\\n';\n    }\n\n    // Load cookies from a text string (e.g. previously created using\n    // `Browser.saveCookies`.\n  }, {\n    key: 'loadCookies',\n    value: function loadCookies(serialized) {\n      var _iteratorNormalCompletion13 = true;\n      var _didIteratorError13 = false;\n      var _iteratorError13 = undefined;\n\n      try {\n        for (var _iterator13 = _getIterator(serialized.split(/\\n+/)), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n          var line = _step13.value;\n\n          line = line.trim();\n          if (line && line[0] !== '#') this.cookies.push(Cookie.parse(line));\n        }\n      } catch (err) {\n        _didIteratorError13 = true;\n        _iteratorError13 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion13 && _iterator13['return']) {\n            _iterator13['return']();\n          }\n        } finally {\n          if (_didIteratorError13) {\n            throw _iteratorError13;\n          }\n        }\n      }\n    }\n\n    // Converts Tough Cookie object into Zombie cookie representation.\n  }, {\n    key: '_cookieProperties',\n    value: function _cookieProperties(cookie) {\n      var properties = {\n        name: cookie.key,\n        value: cookie.value,\n        domain: cookie.domain,\n        path: cookie.path\n      };\n      if (cookie.secure) properties.secure = true;\n      if (cookie.httpOnly) properties.httpOnly = true;\n      if (cookie.expires && cookie.expires < Infinity) properties.expires = cookie.expires;\n      return properties;\n    }\n\n    // Converts cookie name/identifier into an identifier object.\n  }, {\n    key: '_cookieIdentifier',\n    value: function _cookieIdentifier(identifier) {\n      var location = this.location;\n      var domain = location && location.hostname;\n      var path = location && location.pathname || '/';\n      return {\n        name: identifier.name || identifier,\n        domain: identifier.domain || domain,\n        path: identifier.path || path\n      };\n    }\n\n    // -- Local/Session Storage --\n\n    // Returns local Storage based on the document origin (hostname/port). This is the same storage area you can access\n    // from any document of that origin.\n  }, {\n    key: 'localStorage',\n    value: function localStorage(host) {\n      return this._storages.local(host);\n    }\n\n    // Returns session Storage based on the document origin (hostname/port). This is the same storage area you can access\n    // from any document of that origin.\n  }, {\n    key: 'sessionStorage',\n    value: function sessionStorage(host) {\n      return this._storages.session(host);\n    }\n\n    // Save local/session storage to a text string.  You can use this to load the data later on using\n    // `browser.loadStorage`.\n  }, {\n    key: 'saveStorage',\n    value: function saveStorage() {\n      return this._storages.save();\n    }\n\n    // Load local/session storage from a text string (e.g. previously created using `browser.saveStorage`.\n  }, {\n    key: 'loadStorage',\n    value: function loadStorage(serialized) {\n      this._storages.load(serialized);\n    }\n\n    // Scripts\n    // -------\n\n    // Evaluates a JavaScript expression in the context of the current window and returns the result.  When evaluating\n    // external script, also include filename.\n    //\n    // You can also use this to evaluate a function in the context of the window: for timers and asynchronous callbacks\n    // (e.g. XHR).\n  }, {\n    key: 'evaluate',\n    value: function evaluate(code, filename) {\n      if (!this.window) this.open();\n      return this.window._evaluate(code, filename);\n    }\n\n    // Resources\n    // ---------\n\n  }, {\n    key: 'fetch',\n    value: function fetch(input, init) {\n      return this.pipeline._fetch(input, init);\n    }\n\n    // Returns all resources loaded by currently open window.\n  }, {\n    key: 'debug',\n\n    // Debugging\n    // ---------\n\n    // Enable debugging.  You can do this in code instead of setting DEBUG environment variable.\n    value: function debug() {\n      this._debug = Browser._enableDebugging();\n    }\n\n    // Zombie can spit out messages to help you figure out what's going on as your code executes.\n    //\n    // To spit a message to the console when running in debug mode, call this method with one or more values (same as\n    // `console.log`).  You can also call it with a function that will be evaluated only when running in debug mode.\n    //\n    // For example:\n    //     browser.log('Opening page:', url);\n    //     browser.log(function() { return 'Opening page: ' + url });\n  }, {\n    key: 'log',\n    value: function log() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (typeof args[0] === 'function') args = [args[0]()];\n      this.emit('log', format.apply(undefined, _toConsumableArray(args)));\n    }\n\n    // Dump information to the console: Zombie version, current URL, history, cookies, event loop, etc.  Useful for\n    // debugging and submitting error reports.\n  }, {\n    key: 'dump',\n    value: function dump() {\n      var output = arguments.length <= 0 || arguments[0] === undefined ? process.stdout : arguments[0];\n\n      function indent(lines) {\n        return lines.map(function (line) {\n          return '  ' + line + '\\n';\n        }).join('');\n      }\n      output.write('Zombie: ' + Browser.VERSION + '\\n');\n      output.write('URL:    ' + this.window.location.href + '\\n');\n      output.write('\\nHistory:\\n');\n      this.history.dump(output);\n      output.write('\\nCookies:\\n');\n      this.cookies.dump(output);\n      output.write('\\nStorage:\\n');\n\n      if (this.document) {\n        var html = this.html();\n        var slice = html.length > 497 ? html.slice(0, 497) + '...' : html;\n        output.write('Document:\\n' + indent(slice.split('\\n')) + '\\n');\n      } else output.write('No document\\n');\n\n      output.write('\\n');\n      this._eventLoop.dump(output);\n    }\n\n    // -- Static methods ---\n\n    // ### zombie.visit(url, callback)\n    // ### zombie.visit(url, options? callback)\n    //\n    // Creates a new Browser, opens window to the URL and calls the callback when\n    // done processing all events.\n    //\n    // * url -- URL of page to open\n    // * callback -- Called with error, browser\n  }, {\n    key: 'window',\n    get: function get() {\n      return this.tabs.current;\n    }\n  }, {\n    key: 'error',\n    get: function get() {\n      return this.errors[this.errors.length - 1];\n    }\n  }, {\n    key: 'document',\n    get: function get() {\n      return this.window && this.window.document;\n    }\n\n    // browser.body => Element\n    //\n    // Returns the body Element of the current document.\n  }, {\n    key: 'body',\n    get: function get() {\n      return this.querySelector('body');\n    }\n\n    // Element that has the current focus.\n  }, {\n    key: 'activeElement',\n    get: function get() {\n      return this.document && this.document.activeElement;\n    }\n  }, {\n    key: 'location',\n    get: function get() {\n      return this.window && this.window.location;\n    },\n\n    // browser.location = url\n    //\n    // Changes document location, loads new document if necessary (same as setting `window.location`).\n    set: function set(url) {\n      if (this.window) this.window.location = url;else this.open({ url: url });\n    }\n\n    // browser.url => String\n    //\n    // Return the URL of the current document (same as `document.URL`).\n  }, {\n    key: 'url',\n    get: function get() {\n      return this.window && this.window.location.href;\n    }\n  }, {\n    key: 'history',\n    get: function get() {\n      if (!this.window) this.open();\n      return this.window.history;\n    }\n  }, {\n    key: 'resources',\n    get: function get() {\n      return this.window && this.window.resources;\n    }\n\n    // Get Request associated with currently open window\n  }, {\n    key: 'request',\n    get: function get() {\n      return this.window && this.window._request || null;\n    }\n\n    // Get Response associated with currently open window\n  }, {\n    key: 'response',\n    get: function get() {\n      return this.window && this.window._response || null;\n    }\n\n    // Get the status code of the response associated with this window\n  }, {\n    key: 'status',\n    get: function get() {\n      var response = this.response;\n\n      return response ? response.status : 0;\n    }\n  }, {\n    key: 'statusCode',\n    get: function get() {\n      return this.status;\n    }\n\n    // Return true if last response had status code 200 .. 299\n  }, {\n    key: 'success',\n    get: function get() {\n      var status = this.status;\n\n      return status >= 200 && status < 300;\n    }\n\n    // Returns true if the last response followed a redirect\n  }, {\n    key: 'redirected',\n    get: function get() {\n      var request = this.request;\n\n      return request ? request._redirectCount > 0 : false;\n    }\n\n    // Get the source HTML for the last response\n  }, {\n    key: 'source',\n    get: function get() {\n      var response = this.response;\n\n      return response ? response.body : null;\n    }\n  }], [{\n    key: 'visit',\n    value: function visit(url, options, callback) {\n      if (arguments.length === 2 && typeof options === 'function') {\n        ;\n        var _ref5 = [null, options];\n        options = _ref5[0];\n        callback = _ref5[1];\n      }var browser = new Browser(options);\n      if (callback) browser.visit(url, function (error) {\n        return callback(error, browser);\n      });else return browser.visit(url).then(function () {\n        return browser;\n      });\n    }\n\n    // Allows you to make requests against a named domain and HTTP/S port, and\n    // will route it to the test server running on localhost and unprivileged\n    // port.\n  }, {\n    key: 'localhost',\n    value: function localhost(source, target) {\n      reroute(source, target);\n      if (!this.site) {\n        var _source$split = source.split(':');\n\n        var _source$split2 = _slicedToArray(_source$split, 1);\n\n        var hostname = _source$split2[0];\n\n        this.site = hostname.replace(/^\\*\\./, '');\n      }\n    }\n\n    // Register a browser extension.\n    //\n    // Browser extensions are called for each newly created browser object, and\n    // can be used to change browser options, register listeners, add methods,\n    // etc.\n  }, {\n    key: 'extend',\n    value: function extend(extension) {\n      this._extensions.push(extension);\n    }\n\n    // Call this to return a debug() instance with debugging enabled.\n  }, {\n    key: '_enableDebugging',\n    value: function _enableDebugging() {\n      // With debugging enabled, every time we call debug('zombie') we get a new\n      // instance which outputs with a different color.  This can be confusing, so\n      // if debugging is already enabled (DEBUG=zombie) we want to use the current\n      // instance.  Otherwise, we want to create a new instance (_debugEnabled)\n      // and reuse it every time someone calls browser.debug().\n      if (this._debug.enabled) return this._debug.enabled;\n\n      if (!this._debugEnabled) {\n        debug.enable('zombie');\n        this._debugEnabled = debug('zombie');\n      }\n      return this._debugEnabled;\n    }\n\n    // -- Static properties --\n\n  }, {\n    key: 'VERSION',\n    value: VERSION,\n    enumerable: true\n  }, {\n    key: 'Assert',\n    value: Assert,\n    enumerable: true\n  }, {\n    key: 'Pipeline',\n    value: Pipeline,\n    enumerable: true\n  }, {\n    key: 'Headers',\n    value: Fetch.Headers,\n    enumerable: true\n  }, {\n    key: 'Request',\n    value: Fetch.Request,\n    enumerable: true\n  }, {\n    key: 'Response',\n    value: Fetch.Response,\n\n    // -- These defaults are used in any new browser instance --\n\n    // Which features are enabled.\n    enumerable: true\n  }, {\n    key: 'features',\n    value: DEFAULT_FEATURES,\n\n    // Proxy URL.\n    //\n    // Example\n    //   Browser.proxy = 'http://myproxy:8080'\n    enumerable: true\n  }, {\n    key: 'proxy',\n    value: null,\n\n    // If true, suppress `console.log` output from scripts (ignored when DEBUG=zombie)\n    enumerable: true\n  }, {\n    key: 'silent',\n    value: false,\n\n    // You can use visit with a path, and it will make a request relative to this host/URL.\n    enumerable: true\n  }, {\n    key: 'site',\n    value: null,\n\n    // Check SSL certificates against CA.  False by default since you're likely\n    // testing with a self-signed certificate.\n    enumerable: true\n  }, {\n    key: 'strictSSL',\n    value: false,\n\n    // Sets the outgoing IP address in case there is more than on available.\n    // Defaults to 0.0.0.0 which should select default interface\n    enumerable: true\n  }, {\n    key: 'localAddress',\n    value: '0.0.0.0',\n\n    // User agent string sent to server.\n    enumerable: true\n  }, {\n    key: 'userAgent',\n    value: 'Mozilla/5.0 Chrome/10.0.613.0 Safari/534.15 Zombie.js/' + VERSION,\n\n    // Navigator language code\n    enumerable: true\n  }, {\n    key: 'language',\n    value: 'en-US',\n\n    // Default time to wait (visit, wait, etc).\n    enumerable: true\n  }, {\n    key: 'waitDuration',\n    value: '5s',\n\n    // Indicates whether or not to validate and execute JavaScript, default true.\n    enumerable: true\n  }, {\n    key: 'runScripts',\n    value: true,\n\n    // -- Internal properties --\n\n    // Debug instance.  Create new instance when enabling debugging with Zombie.debug\n    enumerable: true\n  }, {\n    key: '_debug',\n    value: debug('zombie'),\n\n    // Set after calling _enableDebugging\n    enumerable: true\n  }, {\n    key: '_debugEnabled',\n    value: null,\n\n    // Browser extensions;\n    enumerable: true\n  }, {\n    key: '_extensions',\n    value: [],\n    enumerable: true\n  }]);\n\n  return Browser;\n})(EventEmitter);\n\nmodule.exports = Browser;\n//# sourceMappingURL=index.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/assert.js":"// Browser assertions convenience.\n\n'use strict';\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar _Number$isInteger = require('babel-runtime/core-js/number/is-integer')['default'];\n\nvar assert = require('assert');\n\nvar _require = require('util');\n\nvar isRegExp = _require.isRegExp;\n\nvar URL = require('url');\nvar Utils = require('jsdom/lib/jsdom/utils');\n\n// Used to assert that actual matches expected value, where expected may be a function or a string.\nfunction assertMatch(actual, expected, message) {\n  if (isRegExp(expected)) assert(expected.test(actual), message || 'Expected \"' + actual + '\" to match \"' + expected + '\"');else if (typeof expected === 'function') assert(expected(actual), message);else assert.deepEqual(actual, expected, message);\n}\n\nmodule.exports = (function () {\n  function Assert(browser) {\n    _classCallCheck(this, Assert);\n\n    this.browser = browser;\n  }\n\n  // -- Location/response --\n\n  // Asserts that a cookie with the given name has the expected value.\n  //\n  // identifier - Cookie name or name/domain/path (see getCookie)\n  // expected   - Expected value (null to test cookie is not set)\n  // message    - Assert message if cookie does not have expected value\n\n  _createClass(Assert, [{\n    key: 'cookie',\n    value: function cookie(identifier) {\n      var expected = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n      var message = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n      var actual = this.browser.getCookie(identifier);\n      assertMatch(actual, expected, message || 'Expected cookie ' + JSON.stringify(identifier) + ' to have the value \"' + expected + '\", found \"' + actual + '\"');\n    }\n\n    // Asserts that browser was redirected when retrieving the current page.\n  }, {\n    key: 'redirected',\n    value: function redirected(message) {\n      assert(this.browser.redirected, message);\n    }\n\n    // Assert that the last page load returned the expected status code.\n  }, {\n    key: 'status',\n    value: function status(code, message) {\n      assert.equal(this.browser.status, code, message);\n    }\n\n    // Assert that the last page load returned status code 200.\n  }, {\n    key: 'success',\n    value: function success(message) {\n      assert(this.browser.success, message);\n    }\n\n    // Asserts that current page has the expected URL.\n    //\n    // Expected value can be a String, RegExp, Function or an object, in which case\n    // object properties are tested against the actual URL (e.g. pathname, host,\n    // query).\n  }, {\n    key: 'url',\n    value: function url(expected, message) {\n      if (typeof expected === 'string') {\n        var absolute = Utils.resolveHref(this.browser.location.href, expected);\n        assertMatch(this.browser.location.href, absolute, message);\n      } else if (isRegExp(expected) || typeof expected === 'function') assertMatch(this.browser.location.href, expected, message);else {\n        var url = URL.parse(this.browser.location.href, true);\n        for (var key in expected) {\n          var value = expected[key];\n          // Gracefully handle default values, e.g. document.location.hash for\n          // \"/foo\" is \"\" not null, not undefined.\n          var defaultValue = key === 'port' ? 80 : null;\n          assertMatch(url[key] || defaultValue, value || defaultValue, message);\n        }\n      }\n    }\n\n    // -- Document contents --\n\n    // Assert the named attribute of the selected element(s) has the expected value.\n  }, {\n    key: 'attribute',\n    value: function attribute(selector, name) {\n      var expected = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n      var message = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];\n\n      var elements = this.browser.queryAll(selector);\n      assert(elements.length, 'Expected selector \"' + selector + '\" to return one or more elements');\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(elements), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var element = _step.value;\n\n          var actual = element.getAttribute(name);\n          assertMatch(actual, expected, message);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    // Assert that element matching selector exists.\n  }, {\n    key: 'element',\n    value: function element(selector, message) {\n      this.elements(selector, { exactly: 1 }, message);\n    }\n\n    // Assert how many elements matching selector exist.\n    //\n    // Count can be an exact number, or an object with the properties:\n    // atLeast - Expect to find at least that many elements\n    // atMost  - Expect to find at most that many elements\n    // exactly - Expect to find exactly that many elements\n    //\n    // If count is unspecified, defaults to at least one.\n  }, {\n    key: 'elements',\n    value: function elements(selector, count, message) {\n      var elements = this.browser.queryAll(selector);\n      if (arguments.length === 1) this.elements(selector, { atLeast: 1 });else if (_Number$isInteger(count)) this.elements(selector, { exactly: count }, message);else {\n        if (_Number$isInteger(count.exactly)) assert.equal(elements.length, count.exactly, message || 'Expected ' + count.exactly + ' elements matching \"' + selector + '\", found ' + elements.length);\n        if (_Number$isInteger(count.atLeast)) assert(elements.length >= count.atLeast, message || 'Expected at least ' + count.atLeast + ' elements matching \"' + selector + '\", found only ' + elements.length);\n        if (_Number$isInteger(count.atMost)) assert(elements.length <= count.atMost, message || 'Expected at most ' + count.atMost + ' elements matching \"' + selector + '\", found ' + elements.length);\n      }\n    }\n\n    // Asserts the selected element(s) has the expected CSS class.\n  }, {\n    key: 'hasClass',\n    value: function hasClass(selector, expected, message) {\n      var elements = this.browser.queryAll(selector);\n      assert(elements.length, 'Expected selector \"' + selector + '\" to return one or more elements');\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = _getIterator(elements), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var element = _step2.value;\n\n          var classNames = element.className.split(/\\s+/);\n          assert(~classNames.indexOf(expected), message || 'Expected element \"' + selector + '\" to have class \"' + expected + '\", found \"' + classNames.join(', ') + '\"');\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n            _iterator2['return']();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    // Asserts the selected element(s) doest not have the expected CSS class.\n  }, {\n    key: 'hasNoClass',\n    value: function hasNoClass(selector, expected, message) {\n      var elements = this.browser.queryAll(selector);\n      assert(elements.length, 'Expected selector \"' + selector + '\" to return one or more elements');\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = _getIterator(elements), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var element = _step3.value;\n\n          var classNames = element.className.split(/\\s+/);\n          assert(classNames.indexOf(expected) === -1, message || 'Expected element \"' + selector + '\" to not have class \"' + expected + '\", found \"' + classNames.join(', ') + '\"');\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3['return']) {\n            _iterator3['return']();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n\n    // Asserts the selected element(s) has the expected class names.\n  }, {\n    key: 'className',\n    value: function className(selector, expected, message) {\n      var elements = this.browser.queryAll(selector);\n      assert(elements.length, 'Expected selector \"' + selector + '\" to return one or more elements');\n      var array = expected.split(/\\s+/).sort().join(' ');\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = _getIterator(elements), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var element = _step4.value;\n\n          var actual = element.className.split(/\\s+/).sort().join(' ');\n          assertMatch(actual, array, message || 'Expected element \"' + selector + '\" to have class \"' + expected + '\", found \"' + actual + '\"');\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4['return']) {\n            _iterator4['return']();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n\n    // Asserts the selected element(s) has the expected value for the named style\n    // property.\n  }, {\n    key: 'style',\n    value: function style(selector, _style) {\n      var expected = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n      var message = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];\n\n      var elements = this.browser.queryAll(selector);\n      assert(elements.length, 'Expected selector \"' + selector + '\" to return one or more elements');\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = _getIterator(elements), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var element = _step5.value;\n\n          var actual = element.style.getPropertyValue(_style);\n          assertMatch(actual, expected, message || 'Expected element \"' + selector + '\" to have style ' + _style + ' value of \"' + expected + '\", found \"' + actual + '\"');\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5['return']) {\n            _iterator5['return']();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    }\n\n    // Asserts that selected input field (text field, text area, etc) has the expected value.\n  }, {\n    key: 'input',\n    value: function input(selector) {\n      var expected = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n      var message = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n      var elements = this.browser.queryAll(selector);\n      assert(elements.length, 'Expected selector \"' + selector + '\" to return one or more elements');\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = _getIterator(elements), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var element = _step6.value;\n\n          assertMatch(element.value, expected, message);\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6['return']) {\n            _iterator6['return']();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n\n    // Asserts that a link exists with the given text and URL.\n  }, {\n    key: 'link',\n    value: function link(selector, text, url, message) {\n      var _this = this;\n\n      var elements = this.browser.queryAll(selector);\n      assert(elements.length, message || 'Expected selector \"' + selector + '\" to return one or more elements');\n      var matchingText = elements.filter(function (element) {\n        return element.textContent.trim() === text;\n      });\n      if (isRegExp(url)) {\n        var matchedRegexp = matchingText.filter(function (element) {\n          return url.test(element.href);\n        });\n        assert(matchedRegexp.length, message || 'Expected at least one link matching the given text and URL');\n      } else {\n        (function () {\n          var absolute = Utils.resolveHref(_this.browser.location.href, url);\n          var matchedURL = matchingText.filter(function (element) {\n            return element.href === absolute;\n          });\n          assert(matchedURL.length, message || 'Expected at least one link matching the given text and URL');\n        })();\n      }\n    }\n\n    // Assert that text content of selected element(s) matches expected string.\n    //\n    // You can also call this with a regular expression, or a function.\n  }, {\n    key: 'text',\n    value: function text(selector, expected, message) {\n      var elements = this.browser.queryAll(selector);\n      assert(elements.length, 'Expected selector \"' + selector + '\" to return one or more elements');\n      var actual = elements.map(function (elem) {\n        return elem.textContent;\n      }).join('').trim().replace(/\\s+/g, ' ');\n      assertMatch(actual, expected || '', message);\n    }\n\n    // -- Window --\n\n    // Asserts that selected element has the focus.\n  }, {\n    key: 'hasFocus',\n    value: function hasFocus(selector, message) {\n      if (selector) {\n        var elements = this.browser.queryAll(selector);\n        assert.equal(elements.length, 1, message || 'Expected selector \"' + selector + '\" to return one element');\n        assert.equal(this.browser.activeElement, elements[0], message || 'Expected element \"' + selector + '\" to have the focus\\'');\n      } else assert.equal(this.browser.activeElement, this.browser.body, message || 'Expected no element to have focus');\n    }\n\n    // -- JavaScript --\n\n    // Evaluates Javascript expression and asserts value.  With one argument,\n    // asserts that the expression evaluates to (JS) true.\n  }, {\n    key: 'evaluate',\n    value: function evaluate(expression, expected, message) {\n      var actual = this.browser.evaluate(expression);\n      if (arguments.length === 1) assert(actual);else assertMatch(actual, expected, message);\n    }\n\n    // Asserts that the global (window) property name has the expected value.\n  }, {\n    key: 'global',\n    value: function global(name, expected, message) {\n      var actual = this.browser.window[name];\n      if (arguments.length === 1) assert(actual);else assertMatch(actual, expected, message || 'Expected global ' + name + ' to have the value \"' + expected + '\", found \"' + actual + '\"');\n    }\n  }]);\n\n  return Assert;\n})();\n//# sourceMappingURL=assert.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/tabs.js":"// Tab management.\n\n'use strict';\n\nvar _get = require('babel-runtime/helpers/get')['default'];\n\nvar _inherits = require('babel-runtime/helpers/inherits')['default'];\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar _ = require('lodash');\nvar createHistory = require('./history');\n\nmodule.exports = (function (_Array) {\n  _inherits(Tabs, _Array);\n\n  function Tabs(browser) {\n    _classCallCheck(this, Tabs);\n\n    _get(Object.getPrototypeOf(Tabs.prototype), 'constructor', this).call(this);\n    this._current = null;\n    this._browser = browser;\n    this.length = 0;\n    Object.defineProperty(this, 'length', { enumerable: false, writable: true });\n    Object.defineProperty(this, '_browser', { enumerable: false, writable: true });\n    Object.defineProperty(this, '_current', { enumerable: false, writable: true });\n  }\n\n  // Get the currently open tab\n\n  _createClass(Tabs, [{\n    key: 'find',\n\n    // Returns window by index or name. Use this for window names that shadow\n    // existing properties (e.g. tabs['open'] is a function, use\n    value: function find(nameOrWindow) {\n      if (this.propertyIsEnumerable(nameOrWindow)) return this[nameOrWindow];\n      var byName = _.find(this, { name: nameOrWindow });\n      if (byName) return byName;\n      if (this._indexOf(nameOrWindow) >= 0) return nameOrWindow;\n      return null;\n    }\n\n    // Index of currently selected tab.\n  }, {\n    key: 'open',\n\n    // Opens and returns a tab.  If an open window by the same name already exists,\n    // opens this window in the same tab.  Omit name or use '_blank' to always open\n    // a new tab.\n    //\n    // name    - Window name (optional)\n    // opener  - Opening window (window.open call)\n    // referer - Referrer\n    // url     - Set document location to this URL upon opening\n    // html    - Document contents (browser.load)\n    value: function open() {\n      var _this = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      // If name window in open tab, reuse that tab. Otherwise, open new window.\n      var named = options.name && this.find(options.name.toString());\n      if (named) {\n        // Select this as the currently open tab. Changing the location would then\n        // select a different window.\n        this._current = named;\n        if (options.url) this._current.location = options.url;\n        return this._current;\n      }\n\n      // When window changes we need to change tab slot. We can't keep the index\n      // around, since tab order changes, so we look up the currently known\n      // active window and switch that around.\n      var active = null;\n      var open = createHistory(this._browser, function (window) {\n        // Focus changes to different window, make it the active window\n        if (!Tabs.sameWindow(window, active)) {\n          var index = _this._indexOf(active);\n          if (index >= 0) _this[index] = window;\n          _this.current = active = window;\n        }\n        if (window) _this._browser._eventLoop.setActiveWindow(window);\n      });\n\n      var name = options.name === '_blank' ? '' : options.name || '';\n      options.name = name;\n      var window = open(options);\n      this.push(window);\n      if (name && (this.propertyIsEnumerable(name) || !this[name])) this[name] = window;\n      // Select this as the currently open tab\n      this.current = active = window;\n      return window;\n    }\n\n    // Close an open tab.\n    //\n    // With no argument, closes the currently open tab (tabs.current).\n    //\n    // Argument can be the window, window name or tab position (same as find).\n  }, {\n    key: 'close',\n    value: function close(nameOrWindow) {\n      var window = nameOrWindow ? this.find(nameOrWindow) : this._current;\n      if (this._indexOf(window) >= 0) window.close();\n    }\n\n    // Closes all open tabs/windows.\n  }, {\n    key: 'closeAll',\n    value: function closeAll() {\n      var tabs = this.slice();\n      this._current = null;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(tabs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var tab = _step.value;\n\n          tab.close();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    // Dump list of all open tabs to stdout or output stream.\n  }, {\n    key: 'dump',\n    value: function dump() {\n      var output = arguments.length <= 0 || arguments[0] === undefined ? process.stdout : arguments[0];\n\n      if (this.length === 0) {\n        output.write('No open tabs.\\n');\n        return;\n      }\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = _getIterator(this), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var tab = _step2.value;\n\n          output.write('Window ' + (tab.name || 'unnamed') + ' open to ' + tab.location.href + '\\n');\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n            _iterator2['return']();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    // Find the position of this window in the tabs array\n  }, {\n    key: '_indexOf',\n    value: function _indexOf(window) {\n      if (!window) return -1;\n      return this.slice().map(function (tab) {\n        return tab._globalProxy;\n      }).indexOf(window._globalProxy);\n    }\n\n    // Called when window closed to remove it from tabs list.\n  }, {\n    key: '_closed',\n    value: function _closed(window) {\n      var index = this._indexOf(window);\n      if (index >= 0) {\n        this._browser.emit('inactive', window);\n\n        this.splice(index, 1);\n        if (this.propertyIsEnumerable(window.name)) delete this[window.name];\n\n        // If we closed the currently open tab, need to select another window.\n        if (Tabs.sameWindow(window, this._current)) {\n          // Don't emit inactive event for closed window.\n          this._current = this[index - 1] || this[0];\n          if (this._current) this._browser.emit('active', this._current);\n        }\n      }\n    }\n\n    // Determine if two windows are the same\n  }, {\n    key: 'current',\n    get: function get() {\n      return this._current;\n    },\n\n    // Sets the currently open tab\n    // - Name   - Pick existing window with this name\n    // - Number - Pick existing window from tab position\n    // - Window - Use this window\n    set: function set(nameOrWindow) {\n      var window = this.find(nameOrWindow);\n      if (this._indexOf(window) < 0) return;\n      if (!Tabs.sameWindow(this._current, window)) {\n        if (this._current) this._browser.emit('inactive', this._current);\n        this._current = window;\n        this._browser.emit('active', this._current);\n      }\n    }\n  }, {\n    key: 'index',\n    get: function get() {\n      return this._indexOf(this._current);\n    }\n  }], [{\n    key: 'sameWindow',\n    value: function sameWindow(a, b) {\n      return a && b && a._globalProxy === b._globalProxy;\n    }\n  }]);\n\n  return Tabs;\n})(Array);\n//# sourceMappingURL=tabs.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/history.js":"// Window history.\n//\n// Each window belongs to a history. Think of history as a timeline, with\n// currently active window, and multiple previous and future windows. From that\n// window you can navigate backwards and forwards between all other windows that\n// belong to the same history.\n//\n// Each window also has a container: either a browser tab or an iframe. When\n// navigating in history, a different window (from the same history), replaces\n// the current window within its container.\n//\n// Containers have access to the currently active window, not the history\n// itself, so navigation has to alert the container when there's a change in the\n// currently active window.\n//\n// The history does so by calling a \"focus\" function. To create the first\n// window, the container must first create a new history and supply a focus\n// function. The result is another function it can use to create the new window.\n//\n// From there on, it can navigate in history and add new windows by changing the\n// current location (or using assign/replace).\n//\n// It can be used like this:\n//\n//   active = null\n//   focus = (window)->\n//     active = window\n//   history = createHistory(browser, focus)\n//   window = history(url: url, name: name)\n\n'use strict';\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];\n\nvar _Object$assign = require('babel-runtime/core-js/object/assign')['default'];\n\nvar assert = require('assert');\nvar loadDocument = require('./document');\nvar resourceLoader = require('jsdom/lib/jsdom/browser/resource-loader');\nvar URL = require('url');\n\nvar Location = (function () {\n  function Location(history, url) {\n    _classCallCheck(this, Location);\n\n    this._history = history;\n    this._url = url || (history.current ? history.current.url : 'about:blank');\n  }\n\n  // Returns true if the hash portion of the URL changed between the history entry\n  // (entry) and the new URL we want to inspect (url).\n\n  _createClass(Location, [{\n    key: 'assign',\n    value: function assign(url) {\n      this._history.assign(url);\n    }\n  }, {\n    key: 'replace',\n    value: function replace(url) {\n      this._history.replace(url);\n    }\n  }, {\n    key: 'reload',\n    value: function reload() {\n      this._history.reload();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._url;\n    }\n  }, {\n    key: 'hostname',\n    get: function get() {\n      return URL.parse(this._url).hostname;\n    },\n    set: function set(hostname) {\n      var newUrl = URL.parse(this._url);\n      if (newUrl.port) newUrl.host = hostname + ':' + newUrl.port;else newUrl.host = hostname;\n      this.assign(URL.format(newUrl));\n    }\n  }, {\n    key: 'href',\n    get: function get() {\n      return this._url;\n    },\n    set: function set(href) {\n      this.assign(URL.format(href));\n    }\n  }, {\n    key: 'origin',\n    get: function get() {\n      return this.protocol + '//' + this.host;\n    }\n  }, {\n    key: 'hash',\n    get: function get() {\n      return URL.parse(this._url).hash || '';\n    },\n    set: function set(value) {\n      var url = _Object$assign(URL.parse(this._url), { hash: value });\n      this.assign(URL.format(url));\n    }\n  }, {\n    key: 'host',\n    get: function get() {\n      return URL.parse(this._url).host || '';\n    },\n    set: function set(value) {\n      var url = _Object$assign(URL.parse(this._url), { host: value });\n      this.assign(URL.format(url));\n    }\n  }, {\n    key: 'pathname',\n    get: function get() {\n      return URL.parse(this._url).pathname || '';\n    },\n    set: function set(value) {\n      var url = _Object$assign(URL.parse(this._url), { pathname: value });\n      this.assign(URL.format(url));\n    }\n  }, {\n    key: 'port',\n    get: function get() {\n      return URL.parse(this._url).port || '';\n    },\n    set: function set(value) {\n      var url = _Object$assign(URL.parse(this._url), { port: value });\n      this.assign(URL.format(url));\n    }\n  }, {\n    key: 'protocol',\n    get: function get() {\n      return URL.parse(this._url).protocol || '';\n    },\n    set: function set(value) {\n      var url = _Object$assign(URL.parse(this._url), { protocol: value });\n      this.assign(URL.format(url));\n    }\n  }, {\n    key: 'search',\n    get: function get() {\n      return URL.parse(this._url).search || '';\n    },\n    set: function set(value) {\n      var url = _Object$assign(URL.parse(this._url), { search: value });\n      this.assign(URL.format(url));\n    }\n  }]);\n\n  return Location;\n})();\n\nfunction hashChange(entry, url) {\n  if (!entry) return false;\n\n  var _url$split = url.split('#');\n\n  var _url$split2 = _slicedToArray(_url$split, 2);\n\n  var aBase = _url$split2[0];\n  var aHash = _url$split2[1];\n\n  var _entry$url$split = entry.url.split('#');\n\n  var _entry$url$split2 = _slicedToArray(_entry$url$split, 2);\n\n  var bBase = _entry$url$split2[0];\n  var bHash = _entry$url$split2[1];\n\n  return aBase === bBase && aHash !== bHash;\n}\n\n// If window is not the top level window, return parent for creating new child\n// window, otherwise returns false.\nfunction parentFrom(window) {\n  if (window.parent !== window) return window.parent;\n}\n\n// Entry has the following properties:\n// window      - Window for this history entry (may be shared with other entries)\n// url         - URL for this history entry\n// pushState   - Push state state\n// next        - Next entry in history\n// prev        - Previous entry in history\n\nvar Entry = (function () {\n  function Entry(window, url, pushState) {\n    _classCallCheck(this, Entry);\n\n    this.window = window;\n    this.url = URL.format(url);\n    this.pushState = pushState;\n    this.prev = null;\n    this.next = null;\n  }\n\n  // Called to destroy this entry. Used when we destroy the entire history,\n  // closing all windows. But also used when we replace one entry with another,\n  // and there are two cases to worry about:\n  // - The current entry uses the same window as the previous entry, we get rid\n  //   of the entry, but must keep the entry intact\n  // - The current entry uses the same window as the new entry, also need to\n  //   keep window intact\n  //\n  // keepAlive - Call destroy on every document except this one, since it's\n  //             being replaced.\n\n  _createClass(Entry, [{\n    key: 'destroy',\n    value: function destroy(keepAlive) {\n      if (this.next) {\n        this.next.destroy(keepAlive || this.window);\n        this.next = null;\n      }\n      // Do not close window if replacing entry with same window\n      if (keepAlive === this.window) return;\n      // Do not close window if used by previous entry in history\n      if (this.prev && this.prev.window === this.window) return;\n      this.window._destroy();\n    }\n  }, {\n    key: 'append',\n    value: function append(newEntry, keepAlive) {\n      if (this.next) this.next.destroy(keepAlive);\n      newEntry.prev = this;\n      this.next = newEntry;\n    }\n  }]);\n\n  return Entry;\n})();\n\nvar History = (function () {\n  function History(browser, focus) {\n    _classCallCheck(this, History);\n\n    this.browser = browser;\n    this.focus = focus;\n    this.first = null;\n    this.current = null;\n  }\n\n  // Creates and returns a new history.\n  //\n  // browser - The browser object\n  // focus   - The focus method, called when a new window is in focus\n  //\n  // Returns a function for opening a new window, which accepts:\n  // name      - Window name (optional)\n  // opener    - Opening window (window.open call)\n  // parent    - Parent window (for frames)\n  // url       - Set document location to this URL upon opening\n\n  // Opens the first window and returns it.\n\n  _createClass(History, [{\n    key: 'open',\n    value: function open(args) {\n      args.browser = this.browser;\n      args.history = this;\n      var document = loadDocument(args);\n      var window = document.defaultView;\n      this.addEntry(window, args.url);\n      return window;\n    }\n\n    // Dispose of all windows in history\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.focus(null);\n      // Re-entrant\n      var first = this.first;\n      this.first = null;\n      this.current = null;\n      if (first) first.destroy();\n    }\n\n    // Add a new entry.  When a window opens it call this to add itself to history.\n  }, {\n    key: 'addEntry',\n    value: function addEntry(window) {\n      var url = arguments.length <= 1 || arguments[1] === undefined ? window.location.href : arguments[1];\n      var pushState = arguments.length <= 2 || arguments[2] === undefined ? undefined : arguments[2];\n      return (function () {\n        var entry = new Entry(window, url, pushState);\n        if (this.current) {\n          this.current.append(entry);\n          this.current = entry;\n        } else {\n          this.first = entry;\n          this.current = entry;\n        }\n        this.focus(window);\n      }).apply(this, arguments);\n    }\n\n    // Replace current entry with a new one.\n  }, {\n    key: 'replaceEntry',\n    value: function replaceEntry(window) {\n      var url = arguments.length <= 1 || arguments[1] === undefined ? window.location.href : arguments[1];\n      var pushState = arguments.length <= 2 || arguments[2] === undefined ? undefined : arguments[2];\n      return (function () {\n        var entry = new Entry(window, url, pushState);\n        if (this.current === this.first) {\n          if (this.current) this.current.destroy(window);\n          this.first = entry;\n          this.current = entry;\n        } else {\n          this.current.prev.append(entry, window);\n          this.current = entry;\n        }\n        this.focus(window);\n      }).apply(this, arguments);\n    }\n\n    // Call with two argument to update window.location and current.url to new URL\n  }, {\n    key: 'updateLocation',\n    value: function updateLocation(window, url) {\n      if (window === this.current) this.current.url = url;\n      window.document._URL = url;\n      window.document._location = new Location(this, url);\n    }\n\n    // Returns window.location\n  }, {\n    key: 'submit',\n\n    // Form submission\n    value: function submit(args) {\n      args.browser = this.browser;\n      args.history = this;\n      var window = this.current.window;\n\n      if (window) {\n        args.name = window.name;\n        args.parent = parentFrom(window);\n        args.referrer = window.location.href;\n      }\n      var document = loadDocument(args);\n      this.addEntry(document.defaultView, document.location.href);\n    }\n\n    // Returns current URL.\n  }, {\n    key: 'assign',\n\n    // -- Implementation of window.history --\n\n    // This method is available from Location, used to navigate to a new page.\n    value: function assign(url) {\n      var _this = this;\n\n      var name = '';\n      var parent = null;\n\n      if (this.current) {\n        url = resourceLoader.resolveResourceUrl(this.current.window.document, url);\n        name = this.current.window.name;\n        parent = parentFrom(this.current.window);\n      }\n      if (this.current && this.current.url === url) {\n        this.replace(url);\n        return;\n      }\n\n      if (hashChange(this.current, url)) {\n        (function () {\n          var window = _this.current.window;\n\n          _this.updateLocation(window, url);\n          _this.addEntry(window, url); // Reuse window with new URL\n          var event = window.document.createEvent('HTMLEvents');\n          event.initEvent('hashchange', true, false);\n          window._eventQueue.enqueue(function () {\n            window.dispatchEvent(event);\n          });\n        })();\n      } else {\n        var args = {\n          browser: this.browser,\n          history: this,\n          name: name,\n          url: url,\n          parent: parent,\n          referrer: this.current && this.current.window.document.referrer\n        };\n        var _document = loadDocument(args);\n        this.addEntry(_document.defaultView, url);\n      }\n    }\n\n    // This method is available from Location, used to navigate to a new page.\n  }, {\n    key: 'replace',\n    value: function replace(url) {\n      var _this2 = this;\n\n      url = URL.format(url);\n      var name = '';\n\n      if (this.current) {\n        url = resourceLoader.resolveResourceUrl(this.current.window.document, url);\n        name = this.current.window.name;\n      }\n\n      if (hashChange(this.current, url)) {\n        (function () {\n          var window = _this2.current.window;\n\n          _this2.replaceEntry(window, url); // Reuse window with new URL\n          var event = window.document.createEvent('HTMLEvents');\n          event.initEvent('hashchange', true, false);\n          window._eventQueue.enqueue(function () {\n            window.dispatchEvent(event);\n          });\n        })();\n      } else {\n        var args = {\n          browser: this.browser,\n          history: this,\n          name: name,\n          url: url,\n          parent: parentFrom(this.current.window)\n        };\n        var _document2 = loadDocument(args);\n        this.replaceEntry(_document2.defaultView, url);\n      }\n    }\n  }, {\n    key: 'reload',\n    value: function reload() {\n      var window = this.current.window;\n\n      if (window) {\n        var url = window.location.href;\n        var args = {\n          browser: this.browser,\n          history: this,\n          name: window.name,\n          url: url,\n          parent: parentFrom(window),\n          referrer: window.document.referrer\n        };\n        var _document3 = loadDocument(args);\n        this.replaceEntry(_document3.defaultView, url);\n      }\n    }\n\n    // This method is available from Location.\n  }, {\n    key: 'go',\n    value: function go(amount) {\n      var _this3 = this;\n\n      var was = this.current;\n      while (amount > 0) {\n        if (this.current.next) this.current = this.current.next;\n        --amount;\n      }\n      while (amount < 0) {\n        if (this.current.prev) this.current = this.current.prev;\n        ++amount;\n      }\n\n      // If moving from one page to another\n      if (this.current && was && this.current !== was) {\n        (function () {\n          var window = _this3.current.window;\n\n          _this3.updateLocation(window, _this3.current.url);\n          _this3.focus(window);\n\n          if (_this3.current.pushState || was.pushState) {\n            // Created with pushState/replaceState, send popstate event if navigating\n            // within same host.\n            var oldHost = URL.parse(was.url).host;\n            var newHost = URL.parse(_this3.current.url).host;\n            if (oldHost === newHost) {\n              (function () {\n                var popstate = window.document.createEvent('HTMLEvents');\n                popstate.initEvent('popstate', false, false);\n                popstate.state = _this3.current.pushState;\n                window._eventQueue.enqueue(function () {\n                  window.dispatchEvent(popstate);\n                });\n              })();\n            }\n          } else if (hashChange(was, _this3.current.url)) {\n            (function () {\n              var hashchange = window.document.createEvent('HTMLEvents');\n              hashchange.initEvent('hashchange', true, false);\n              window._eventQueue.enqueue(function () {\n                window.dispatchEvent(hashchange);\n              });\n            })();\n          }\n        })();\n      }\n    }\n\n    // This method is available from Location.\n  }, {\n    key: 'pushState',\n\n    // This method is available from Location.\n    value: function pushState(state, title) {\n      var url = arguments.length <= 2 || arguments[2] === undefined ? this.url : arguments[2];\n\n      url = resourceLoader.resolveResourceUrl(this.current.window.document, url);\n      // TODO: check same origin\n      this.addEntry(this.current.window, url, state || {});\n      this.updateLocation(this.current.window, url);\n    }\n\n    // This method is available from Location.\n  }, {\n    key: 'replaceState',\n    value: function replaceState(state, title) {\n      var url = arguments.length <= 2 || arguments[2] === undefined ? this.url : arguments[2];\n\n      url = resourceLoader.resolveResourceUrl(this.current.window.document, url);\n      // TODO: check same origin\n      this.replaceEntry(this.current.window, url, state || {});\n      this.updateLocation(this.current.window, url);\n    }\n\n    // This method is available from Location.\n  }, {\n    key: 'dump',\n    value: function dump() {\n      var output = arguments.length <= 0 || arguments[0] === undefined ? process.stdout : arguments[0];\n\n      for (var entry = this.first, i = 1; entry; entry = entry.next, ++i) {\n        output.write(i + ': ' + URL.format(entry.url) + '\\n');\n      }\n    }\n  }, {\n    key: 'location',\n    get: function get() {\n      return new Location(this);\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return this.current && this.current.url;\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      var entry = this.first;\n      var length = 0;\n      while (entry) {\n        ++length;\n        entry = entry.next;\n      }\n      return length;\n    }\n  }, {\n    key: 'state',\n    get: function get() {\n      return this.current.pushState;\n    }\n  }]);\n\n  return History;\n})();\n\nmodule.exports = function createHistory(browser, focus) {\n  assert(browser && browser.visit, 'Missing parameter browser');\n  assert(focus && focus.call, 'Missing parameter focus or not a function');\n  var history = new History(browser, focus);\n  return history.open.bind(history);\n};\n//# sourceMappingURL=history.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/document.js":"// Exports a function for creating/loading new documents.\n\n'use strict';\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _toArray = require('babel-runtime/helpers/to-array')['default'];\n\nvar _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];\n\nvar _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];\n\nvar _Object$defineProperties = require('babel-runtime/core-js/object/define-properties')['default'];\n\nvar _Object$getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor')['default'];\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar _Object$assign = require('babel-runtime/core-js/object/assign')['default'];\n\nvar _Map = require('babel-runtime/core-js/map')['default'];\n\nvar assert = require('assert');\nvar browserFeatures = require('jsdom/lib/jsdom/browser/documentfeatures');\nvar Fetch = require('./fetch');\nvar DOM = require('./dom');\nvar EventSource = require('eventsource');\nvar iconv = require('iconv-lite');\nvar QS = require('querystring');\nvar resourceLoader = require('jsdom/lib/jsdom/browser/resource-loader');\nvar Resources = require('./resources');\nvar URL = require('url');\nvar Utils = require('jsdom/lib/jsdom/utils');\nvar VM = require('vm');\nvar WebSocket = require('ws');\nvar Window = require('jsdom/lib/jsdom/browser/Window');\nvar XMLHttpRequest = require('./xhr');\n\n// File access, not implemented yet\n\nvar File = function File() {\n  _classCallCheck(this, File);\n}\n\n// Screen object provides access to screen dimensions\n;\n\nvar Screen = (function () {\n  function Screen() {\n    _classCallCheck(this, Screen);\n\n    this.top = this.left = 0;\n    this.width = 1280;\n    this.height = 800;\n  }\n\n  // DOM implementation of URL class\n\n  _createClass(Screen, [{\n    key: 'availLeft',\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: 'availTop',\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: 'availWidth',\n    get: function get() {\n      return 1280;\n    }\n  }, {\n    key: 'availHeight',\n    get: function get() {\n      return 800;\n    }\n  }, {\n    key: 'colorDepth',\n    get: function get() {\n      return 24;\n    }\n  }, {\n    key: 'pixelDepth',\n    get: function get() {\n      return 24;\n    }\n  }]);\n\n  return Screen;\n})();\n\nvar DOMURL = (function () {\n  function DOMURL(url, base) {\n    _classCallCheck(this, DOMURL);\n\n    if (url == null) throw new TypeError('Failed to construct \\'URL\\': Invalid URL');\n    if (base) url = Utils.resolveHref(base, url);\n    var parsed = URL.parse(url || 'about:blank');\n    var origin = parsed.protocol && parsed.hostname && parsed.protocol + '//' + parsed.hostname;\n    _Object$defineProperties(this, {\n      hash: { value: parsed.hash, enumerable: true },\n      host: { value: parsed.host, enumerable: true },\n      hostname: { value: parsed.hostname, enumerable: true },\n      href: { value: URL.format(parsed), enumerable: true },\n      origin: { value: origin, enumerable: true },\n      password: { value: parsed.password, enumerable: true },\n      pathname: { value: parsed.pathname, enumerable: true },\n      port: { value: parsed.port, enumerable: true },\n      protocol: { value: parsed.protocol, enumerable: true },\n      search: { value: parsed.search, enumerable: true },\n      username: { value: parsed.username, enumerable: true }\n    });\n  }\n\n  _createClass(DOMURL, [{\n    key: 'toString',\n    value: function toString() {\n      return this.href;\n    }\n  }]);\n\n  return DOMURL;\n})();\n\nfunction setupWindow(window, args) {\n  var document = window.document;\n  var browser = args.browser;\n  var history = args.history;\n  var parent = args.parent;\n  var opener = args.opener;\n\n  var closed = false;\n\n  // Catch all errors\n  window.onerror = function (message, filename, lineno, colno, error) {\n    window._eventQueue.enqueue(function () {\n      return browser.emit('error', error);\n    });\n  };\n\n  // Access to browser\n  Object.defineProperty(window, 'browser', {\n    value: browser,\n    enumerable: true\n  });\n\n  window.name = args.name || '';\n\n  // If this was opened from another window\n  window.opener = opener && opener._globalProxy;\n  // Frames provide their own parent reference\n  window._parent = parent || window;\n  window._top = (parent || window).top;\n\n  window.console = browser.console;\n\n  // All the resources loaded by this window.\n  window.resources = new Resources(window);\n\n  // javaEnabled, present in browsers, not in spec Used by Google Analytics see\n  /// https://developer.mozilla.org/en/DOM/window.navigator.javaEnabled\n  var emptySet = [];\n  emptySet.item = function () {\n    return undefined;\n  };\n  emptySet.namedItem = function () {\n    return undefined;\n  };\n  window.navigator = {\n    appName: 'Zombie',\n    appVersion: browser.constructor.VERSION,\n    cookieEnabled: true,\n    javaEnabled: function javaEnabled() {\n      return false;\n    },\n    language: browser.language,\n    mimeTypes: emptySet,\n    noUI: true,\n    platform: process.platform,\n    plugins: emptySet,\n    userAgent: browser.userAgent,\n    vendor: 'Zombie Industries'\n  };\n\n  // Add cookies, storage, alerts/confirm, XHR, WebSockets, JSON, Screen, etc\n  Object.defineProperty(window, 'cookies', {\n    get: function get() {\n      return browser.cookies.serialize(this.location.hostname, this.location.pathname);\n    }\n  });\n  browser._storages.extend(window);\n\n  window.File = File;\n  window.Event = DOM.Event;\n  window.MouseEvent = DOM.MouseEvent;\n  window.MutationEvent = DOM.MutationEvent;\n  window.UIEvent = DOM.UIEvent;\n  window.screen = new Screen();\n\n  // Fetch API\n  window.fetch = window.resources._fetch.bind(window.resources);\n  window.Request = Fetch.Request;\n  window.Response = Fetch.Response;\n  window.FormData = Fetch.FormData;\n\n  // Base-64 encoding/decoding\n  window.atob = function (string) {\n    return new Buffer(string, 'base64').toString('utf8');\n  };\n  window.btoa = function (string) {\n    return new Buffer(string, 'utf8').toString('base64');\n  };\n\n  // Constructor for XHLHttpRequest\n  window.XMLHttpRequest = function () {\n    return new XMLHttpRequest(window);\n  };\n  window.URL = DOMURL;\n\n  // Web sockets\n  window._allWebSockets = [];\n\n  window.WebSocket = function (url, protocol) {\n    url = resourceLoader.resolveResourceUrl(document, url);\n    var origin = window.location.protocol + '//' + window.location.host;\n    var ws = new WebSocket(url, { origin: origin, protocol: protocol });\n\n    // The < 1.x implementations of ws used to allows 'buffer' to be defined\n    // as the binary type in node environments. Now, the supported type is\n    // 'nodebuffer'. Version of engine.io-client <= 1.6.12 use the 'buffer'\n    // type and this is a shim to allow that to keep working unti that version\n    // of engine.io-client does not need to be supported anymore\n    var origProperty = _Object$getOwnPropertyDescriptor(WebSocket.prototype, 'binaryType');\n    Object.defineProperty(ws, 'binaryType', {\n      get: function get() {\n        return origProperty.get.call(this);\n      },\n      set: function set(type) {\n        if (type === 'buffer') {\n          type = 'nodebuffer';\n        }\n        return origProperty.set.call(this, type);\n      }\n    });\n    window._allWebSockets.push(ws);\n    return ws;\n  };\n\n  window.Image = function (width, height) {\n    var img = new DOM.HTMLImageElement(window.document);\n    img.width = width;\n    img.height = height;\n    return img;\n  };\n\n  // DataView: get from globals\n  window.DataView = DataView;\n\n  window.resizeTo = function (width, height) {\n    window.outerWidth = window.innerWidth = width;\n    window.outerHeight = window.innerHeight = height;\n  };\n  window.resizeBy = function (width, height) {\n    window.resizeTo(window.outerWidth + width, window.outerHeight + height);\n  };\n\n  // Some libraries (e.g. Backbone) check that this property exists before\n  // deciding to use onhashchange, so we need to set it to null.\n  window.onhashchange = null;\n\n  // -- JavaScript evaluation\n\n  // Evaluate in context of window. This can be called with a script (String) or a function.\n  window._evaluate = function (code, filename) {\n    var originalInScope = browser._windowInScope;\n    try {\n      // The current window, postMessage and window.close need this\n      browser._windowInScope = window;\n      var result = undefined;\n      if (typeof code === 'string' || code instanceof String) result = VM.runInContext(code, window, { filename: filename });else if (code) result = code.call(window);\n      browser.emit('evaluated', code, result, filename);\n      return result;\n    } catch (error) {\n      error.filename = error.filename || filename;\n      throw error;\n    } finally {\n      browser._windowInScope = originalInScope;\n    }\n  };\n\n  // -- Event loop --\n\n  var eventQueue = browser._eventLoop.createEventQueue(window);\n  Object.defineProperty(window, '_eventQueue', {\n    value: eventQueue\n  });\n  window.setTimeout = eventQueue.setTimeout.bind(eventQueue);\n  window.clearTimeout = eventQueue.clearTimeout.bind(eventQueue);\n  window.setInterval = eventQueue.setInterval.bind(eventQueue);\n  window.clearInterval = eventQueue.clearInterval.bind(eventQueue);\n  window.setImmediate = function (fn) {\n    return eventQueue.setTimeout(fn, 0);\n  };\n  window.clearImmediate = eventQueue.clearTimeout.bind(eventQueue);\n  window.requestAnimationFrame = window.setImmediate;\n\n  // Constructor for EventSource, URL is relative to document's.\n  window.EventSource = function (url) {\n    url = resourceLoader.resolveResourceUrl(document, url);\n    var eventSource = new EventSource(url);\n    eventQueue.addEventSource(eventSource);\n    return eventSource;\n  };\n\n  // -- Interaction --\n\n  window.alert = function (message) {\n    var handled = browser.emit('alert', message);\n    if (!handled) browser.log('Unhandled window.alert(\"%s\")');\n    browser.log('alert(\"%s\")', message);\n  };\n\n  window.confirm = function (question) {\n    var event = { question: question, response: true };\n    var handled = browser.emit('confirm', event);\n    if (!handled) browser.log('Unhandled window.confirm(\"%s\")');\n    var response = !!event.response;\n    browser.log('confirm(\"%s\") -> %ss', question, response);\n    return response;\n  };\n\n  window.prompt = function (question, value) {\n    var event = { question: question, response: value || '' };\n    var handled = browser.emit('prompt', event);\n    if (!handled) browser.log('Unhandled window.prompt(\"%s\")');\n    var response = (event.response || '').toString();\n    browser.log('prompt(\"..\") -> \"%s\"', question, response);\n    return response;\n  };\n\n  // -- Opening and closing --\n\n  // Open one window from another.\n  window.open = function (url, name) {\n    url = url && resourceLoader.resolveResourceUrl(document, url);\n    return browser.tabs.open({ name: name, url: url, opener: window });\n  };\n\n  // Indicates if window was closed\n  Object.defineProperty(window, 'closed', {\n    get: function get() {\n      return closed;\n    },\n    enumerable: true\n  });\n\n  // Used by window.close() and also from history.destroy/replace/etc\n  // global.\n  window._destroy = function () {\n    // We call history.destroy which calls destroy on all windows, so need to\n    // avoid infinite loop.\n    if (closed) return;\n    closed = true;\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _getIterator(window._allWebSockets), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var ws = _step.value;\n\n        ws.removeAllListeners();\n        ws.close();\n      }\n\n      // Close all frames first\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator['return']) {\n          _iterator['return']();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    for (var i = 0; i < window._length; ++i) {\n      if (window[i]) window[i].close();\n    } // kill event queue, document and window.\n    eventQueue.destroy();\n    document.close();\n  };\n\n  // window.close actually closes the tab, and disposes of all windows in the history.\n  // Also used to close iframe.\n  window.close = function () {\n    if (parent || closed) return;\n\n    // Only opener window can close window; any code that's not running from\n    // within a window's context can also close window.\n    if (browser._windowInScope === opener || browser._windowInScope === null) {\n      browser.tabs._closed(window);\n      // Only parent window gets the close event\n      browser.emit('closed', window);\n      history.destroy(); // do this last to prevent infinite loop\n    } else browser.log('Scripts may not close windows that were not opened by script');\n  };\n\n  // -- Navigating --\n\n  // Each window maintains its own view of history\n  var windowHistory = {\n    forward: function forward() {\n      windowHistory.go(1);\n    },\n    back: function back() {\n      windowHistory.go(-1);\n    },\n    go: function go(amount) {\n      history.go(amount);\n    },\n    pushState: function pushState() {\n      history.pushState.apply(history, arguments);\n    },\n    replaceState: function replaceState() {\n      history.replaceState.apply(history, arguments);\n    },\n    dump: function dump(output) {\n      history.dump(output);\n    }\n  };\n  _Object$defineProperties(windowHistory, {\n    length: {\n      get: function get() {\n        return history.length;\n      },\n      enumerable: true\n    },\n    state: {\n      get: function get() {\n        return history.state;\n      },\n      enumerable: true\n    }\n  });\n\n  // DOM History object\n  window.history = windowHistory;\n  /// Actual history, see location getter/setter\n  window._history = history;\n\n  // Read/write access to window.location\n  Object.defineProperty(window, 'location', {\n    get: function get() {\n      return document.location;\n    },\n    set: function set(url) {\n      history.assign(url);\n    }\n  });\n\n  // Form submission uses this\n  window._submit = function (formArgs) {\n    var url = resourceLoader.resolveResourceUrl(document, formArgs.url);\n    var target = formArgs.target || '_self';\n    browser.emit('submit', url, target);\n    // Figure out which history is going to handle this\n    var targetWindow = target === '_self' ? window : target === '_parent' ? window.parent : target === '_top' ? window.top : browser.tabs.open({ name: target });\n    var modified = _Object$assign({}, formArgs, { url: url, target: target });\n    targetWindow._history.submit(modified);\n  };\n\n  // Overload jsdom postMessage function, which is added to the window object\n  // when created jsdom/lib/jsdom/browser/Window.js.\n  // This is needed because jsdom's implementation does not define the source\n  // and origin attributes in the issued events.\n  // This implementation should be dropped in favor of\n  // jsdom/lib/jsdom/living/post-message.js when it supports source and origin.\n  window.postMessage = function (data) {\n    // Window A (source) calls B.postMessage, to determine A we need the\n    // caller's window.\n\n    // DDOPSON-2012-11-09 - _windowInScope.getGlobal() is used here so that for\n    // website code executing inside the sandbox context, event.source ==\n    // window. Even though the _windowInScope object is mapped to the sandboxed\n    // version of the object returned by getGlobal, they are not the same object\n    // ie, _windowInScope.foo == _windowInScope.getGlobal().foo, but\n    // _windowInScope != _windowInScope.getGlobal()\n    var source = this.browser._windowInScope || this;\n\n    var origin = source.location;\n    var eventOrigin = URL.format({ protocol: origin.protocol, host: origin.host });\n\n    var event = this.document.createEvent('MessageEvent');\n    event.initMessageEvent('message', false, false, data, eventOrigin, null, source, []);\n\n    this.dispatchEvent(event);\n  };\n\n  // JSDOM fires DCL event on document but not on window\n  function windowLoaded(event) {\n    document.removeEventListener('DOMContentLoaded', windowLoaded);\n\n    // JSDom > 7.1 does not allow re-dispatching the same event, so\n    // a copy of the event needs to be created for the new dispatch\n    var windowContentLoaded = document.createEvent('HTMLEvents');\n    windowContentLoaded.initEvent('DOMContentLoaded', false, false);\n    window.dispatchEvent(windowContentLoaded);\n  }\n  document.addEventListener('DOMContentLoaded', windowLoaded);\n\n  // Window is now open, next load the document.\n  browser.emit('opened', window);\n}\n\n// Change location\nDOM.Document.prototype.__defineSetter__('location', function (url) {\n  this.defaultView.location = url;\n});\n\n// Creates an returns a new document attached to the window.\nfunction createDocument(args) {\n  var browser = args.browser;\n\n  var features = {\n    FetchExternalResources: [],\n    ProcessExternalResources: [],\n    MutationEvents: '2.0'\n  };\n  if (args.browser.hasFeature('scripts', true)) {\n    features.FetchExternalResources.push('script');\n    features.ProcessExternalResources.push('script');\n  }\n  if (args.browser.hasFeature('css', false)) {\n    features.FetchExternalResources.push('css');\n    features.FetchExternalResources.push('link');\n  }\n  if (args.browser.hasFeature('img', false)) features.FetchExternalResources.push('img');\n  if (args.browser.hasFeature('iframe', true)) features.FetchExternalResources.push('iframe');\n\n  var window = new Window({\n    parsingMode: 'html',\n    contentType: 'text/html',\n    url: args.url,\n    referrer: args.referrer\n  });\n  var document = window.document;\n\n  browserFeatures.applyDocumentFeatures(document, features);\n  setupWindow(window, args);\n\n  // Give event handler chance to register listeners.\n  args.browser.emit('loading', document);\n  return document;\n}\n\n// Get refresh URL and timeout from <meta> tag\nfunction getMetaRefresh(document) {\n  var refresh = document.querySelector('meta[http-equiv=\"refresh\"]');\n  if (refresh) {\n    var content = refresh.getAttribute('content');\n    var match = content.match(/^\\s*(\\d+)(?:\\s*;\\s*url\\s*=\\s*(.*?))?\\s*(?:;|$)/i);\n    if (match) {\n      var refreshTimeout = parseInt(match[1], 10);\n      var refreshURL = match[2] || document.location.href;\n      if (refreshTimeout >= 0) return { refreshTimeout: refreshTimeout, refreshURL: refreshURL };\n    }\n  }\n  return null;\n}\n\n// Find the charset= value of the meta tag\nvar MATCH_CHARSET = /<meta(?!\\s*(?:name|value)\\s*=)[^>]*?charset\\s*=[\\s\"']*([^\\s\"'\\/>]*)/i;\n\n// Extract HTML from response with the proper encoding:\n// - If content type header indicates charset use that\n// - Otherwise, look for <meta> tag with charset in body\n// - Otherwise, browsers default to windows-1252 encoding\nfunction getHTMLFromResponseBody(buffer, contentType) {\n  var _contentType$split = contentType.split(/;\\s*/);\n\n  var _contentType$split2 = _toArray(_contentType$split);\n\n  var mimeType = _contentType$split2[0];\n\n  var typeOptions = _contentType$split2.slice(1);\n\n  // Pick charset from content type\n  if (mimeType) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = _getIterator(typeOptions), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var typeOption = _step2.value;\n\n        if (/^charset=/i.test(typeOption)) {\n          var charset = typeOption.split('=')[1];\n          return iconv.decode(buffer, charset);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n          _iterator2['return']();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  } // Otherwise, HTML documents only, pick charset from meta tag\n  // Otherwise, HTML documents only, default charset in US is windows-1252\n  var charsetInMetaTag = buffer.toString().match(MATCH_CHARSET);\n  if (charsetInMetaTag) return iconv.decode(buffer, charsetInMetaTag[1]);else return iconv.decode(buffer, 'windows-1252');\n}\n\n// Builds and returns a new Request, adding form parameters to URL (GET) or\n// request body (POST).\nfunction buildRequest(args) {\n  var browser = args.browser;\n  var method = args.method;\n\n  var params = args.params || new _Map();\n  var site = /^(https?:|file:)/i.test(browser.site) ? browser.site : 'http://' + (browser.site || 'locahost');\n  var url = Utils.resolveHref(site, URL.format(args.url));\n\n  var headers = new Fetch.Headers(args.headers);\n\n  // HTTP header Referer, but Document property referrer\n  var referrer = args.referrer || browser.referrer || browser.referer || args.history.url;\n  if (referrer && !headers.has('Referer')) headers.set('Referer', referrer);\n  if (!headers.has('Accept')) headers.set('Accept', 'text/html,*/*');\n\n  if (/^GET|HEAD|DELETE$/i.test(method)) {\n    var uri = URL.parse(url, true);\n    // These methods use query string parameters instead\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = _getIterator(params), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _step3$value = _slicedToArray(_step3.value, 2);\n\n        var _name = _step3$value[0];\n        var values = _step3$value[1];\n\n        uri.query[_name] = values;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3['return']) {\n          _iterator3['return']();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    return new Fetch.Request(URL.format(uri), { method: method, headers: headers });\n  }\n\n  var mimeType = (args.encoding || '').split(';')[0];\n  // Default mime type, but can also be specified in form encoding\n  if (mimeType === '' || mimeType === 'application/x-www-form-urlencoded') {\n    var urlEncoded = [].concat(_toConsumableArray(params)).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      var name = _ref2[0];\n      var values = _ref2[1];\n\n      return values.map(function (value) {\n        return QS.escape(name) + '=' + QS.escape(value);\n      }).join('&');\n    }).join('&');\n\n    headers.set('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');\n    return new Fetch.Request(url, { method: method, headers: headers, body: urlEncoded });\n  }\n\n  if (mimeType === 'multipart/form-data') {\n    var form = new Fetch.FormData();\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = _getIterator(params), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _step4$value = _slicedToArray(_step4.value, 2);\n\n        var _name2 = _step4$value[0];\n        var values = _step4$value[1];\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = _getIterator(values), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var value = _step5.value;\n\n            form.append(_name2, value);\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5['return']) {\n              _iterator5['return']();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4['return']) {\n          _iterator4['return']();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    return new Fetch.Request(url, { method: method, headers: headers, body: form });\n  }\n\n  throw new TypeError('Unsupported content type ' + mimeType);\n}\n\n// Parse HTML response and setup document\nfunction parseResponse(_ref3) {\n  var browser = _ref3.browser;\n  var history = _ref3.history;\n  var document = _ref3.document;\n  var response = _ref3.response;\n\n  var window = document.defaultView;\n  window._request = response.request;\n  window._response = response;\n  history.updateLocation(window, response._url);\n\n  var done = window._eventQueue.waitForCompletion();\n  response._consume().then(function (body) {\n\n    var contentType = response.headers.get('Content-Type') || '';\n    var html = getHTMLFromResponseBody(body, contentType);\n    response.body = html;\n    document.write(html || '<html></html>');\n    document.close();\n\n    browser.emit('loaded', document);\n    if (response.status >= 400) throw new Error('Server returned status code ' + response.status + ' from ' + response.url);\n    if (!document.documentElement) throw new Error('Could not parse document at ' + response.url);\n  }).then(function () {\n\n    // Handle meta refresh.  Automatically reloads new location and counts\n    // as a redirect.\n    //\n    // If you need to check the page before refresh takes place, use this:\n    //   browser.wait({\n    //     function: function() {\n    //       return browser.query('meta[http-equiv=\"refresh\"]');\n    //     }\n    //   });\n    var refresh = getMetaRefresh(document);\n\n    if (refresh) {\n      (function () {\n        var refreshTimeout = refresh.refreshTimeout;\n        var refreshURL = refresh.refreshURL;\n\n        window._eventQueue.setTimeout(function () {\n          // Allow completion function to run\n          window._eventQueue.enqueue(function () {\n            window._eventQueue.enqueue(function () {\n              // Count a meta-refresh in the redirects count.\n              history.replace(refreshURL);\n              // This results in a new window getting loaded\n              var newWindow = history.current.window;\n              newWindow.addEventListener('load', function () {\n                ++newWindow._request._redirectCount;\n              });\n            });\n          });\n        }, refreshTimeout * 1000);\n      })();\n    }\n  })['catch'](function (error) {\n    browser.emit('error', error);\n  }).then(done);\n}\n\n// Load/create a new document.\n//\n// Named arguments:\n// browser   - The browser (required)\n// history   - Window history (required)\n// url       - URL of document to open (defaults to \"about:blank\")\n// method    - HTTP method (defaults to \"GET\")\n// encoding  - Request content type (forms use this)\n// params    - Additional request parameters (Map)\n// html      - Create document with this content instead of loading from URL\n// name      - Window name\n// referrer  - HTTP referer header\n// parent    - Parent document (for frames)\n// opener    - Opening window (for window.open)\n// target    - Target window name (for form.submit)\n//\n// Returns a new document with a new window.  The document contents is loaded\n// asynchronously, and will trigger a loaded/error event.\nmodule.exports = function loadDocument(args) {\n  var browser = args.browser;\n  var history = args.history;\n  var html = args.html;\n  var url = args.url;\n\n  assert(browser && browser.visit, 'Missing parameter browser');\n  assert(history && history.reload, 'Missing parameter history');\n\n  var document = createDocument(_Object$assign({ url: url }, args));\n  var window = document.defaultView;\n\n  if (html) {\n    window._eventQueue.enqueue(function () {\n      document.write(html);\n      document.close();\n      browser.emit('loaded', document);\n    });\n    return document;\n  }\n\n  // Let's handle the specifics of each protocol\n  if (!url || /^about:/.test(url)) {\n    window._eventQueue.enqueue(function () {\n      document.close();\n      browser.emit('loaded', document);\n    });\n    return document;\n  }\n\n  if (/^javascript:/.test(url)) {\n    window._eventQueue.enqueue(function () {\n      document.close();\n      try {\n        window._evaluate(url.slice(11), 'javascript:');\n        browser.emit('loaded', document);\n      } catch (error) {\n        browser.emit('error', error);\n      }\n    });\n    return document;\n  }\n\n  var request = buildRequest(args);\n  window._eventQueue.http(request, function (error, response) {\n    if (error) {\n      document.write('<html><body>' + error.message + '</body></html>');\n      document.close();\n      browser.emit('error', error);\n    } else parseResponse({ browser: browser, history: history, document: document, response: response });\n  });\n  return document;\n};\n//# sourceMappingURL=document.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/fetch.js":"'use strict';\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _get = require('babel-runtime/helpers/get')['default'];\n\nvar _inherits = require('babel-runtime/helpers/inherits')['default'];\n\nvar _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar _Symbol$iterator = require('babel-runtime/core-js/symbol/iterator')['default'];\n\nvar _Object$create = require('babel-runtime/core-js/object/create')['default'];\n\nvar _Promise = require('babel-runtime/core-js/promise')['default'];\n\nvar _ = require('lodash');\nvar HTTP = require('http');\nvar Stream = require('stream');\nvar URL = require('url');\nvar Zlib = require('zlib');\n\n// Decompress stream based on content and transfer encoding headers.\nfunction decompressStream(stream, headers) {\n  var transferEncoding = headers.get('Transfer-Encoding');\n  var contentEncoding = headers.get('Content-Encoding');\n  if (contentEncoding === 'deflate' || transferEncoding === 'deflate') return stream.pipe(Zlib.createInflate());\n  if (contentEncoding === 'gzip' || transferEncoding === 'gzip') return stream.pipe(Zlib.createGunzip());\n  return stream;\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\n\nvar Headers = (function () {\n  function Headers(init) {\n    var _this = this;\n\n    _classCallCheck(this, Headers);\n\n    this._headers = [];\n    if (init instanceof Headers || init instanceof Array) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(init), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2);\n\n          var _name = _step$value[0];\n          var value = _step$value[1];\n\n          this.append(_name, value);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } else if (typeof init === \"object\") _.each(init, function (value, name) {\n      _this.append(name, value);\n    });\n  }\n\n  _createClass(Headers, [{\n    key: 'append',\n    value: function append(name, value) {\n      var caseInsensitive = name.toLowerCase();\n      var castValue = String(value).replace(/\\r\\n/g, '');\n      this._headers.push([caseInsensitive, castValue]);\n    }\n  }, {\n    key: 'delete',\n    value: function _delete(name) {\n      var caseInsensitive = name.toLowerCase();\n      this._headers = this._headers.filter(function (header) {\n        return header[0] !== caseInsensitive;\n      });\n    }\n  }, {\n    key: 'get',\n    value: function get(name) {\n      var caseInsensitive = name.toLowerCase();\n      var namedHeader = _.find(this._headers, function (header) {\n        return header[0] === caseInsensitive;\n      });\n      return namedHeader ? namedHeader[1] : null;\n    }\n  }, {\n    key: 'getAll',\n    value: function getAll(name) {\n      var caseInsensitive = name.toLowerCase();\n      return this._headers.filter(function (header) {\n        return header[0] === caseInsensitive;\n      }).map(function (header) {\n        return header[1];\n      });\n    }\n  }, {\n    key: 'has',\n    value: function has(name) {\n      var caseInsensitive = name.toLowerCase();\n      var namedHeader = _.find(this._headers, function (header) {\n        return header[0] === caseInsensitive;\n      });\n      return !!namedHeader;\n    }\n  }, {\n    key: 'set',\n    value: function set(name, value) {\n      var caseInsensitive = name.toLowerCase();\n      var castValue = String(value).replace(/\\r\\n/g, '');\n      var replaced = false;\n      this._headers = this._headers.reduce(function (memo, header) {\n        if (header[0] !== caseInsensitive) memo.push(header);else if (!replaced) {\n          memo.push([header[0], castValue]);\n          replaced = true;\n        }\n        return memo;\n      }, []);\n\n      if (!replaced) this.append(name, value);\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return _getIterator(this._headers);\n    }\n  }, {\n    key: 'valueOf',\n    value: function valueOf() {\n      return this._headers.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        var name = _ref2[0];\n        var value = _ref2[1];\n        return name + ': ' + value;\n      });\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.valueOf().join('\\n');\n    }\n  }, {\n    key: 'toObject',\n    value: function toObject() {\n      var object = _Object$create(null);\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = _getIterator(this._headers), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = _slicedToArray(_step2.value, 2);\n\n          var _name2 = _step2$value[0];\n          var value = _step2$value[1];\n\n          object[_name2] = value;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n            _iterator2['return']();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return object;\n    }\n  }]);\n\n  return Headers;\n})();\n\nvar FormData = (function () {\n  function FormData() {\n    _classCallCheck(this, FormData);\n\n    this._entries = [];\n  }\n\n  _createClass(FormData, [{\n    key: 'append',\n    value: function append(name, value /*, filename*/) {\n      // TODO add support for files\n      this._entries.push([name, value]);\n    }\n  }, {\n    key: 'set',\n    value: function set(name, value, filename) {\n      this['delete'](name);\n      this.append(name, value, filename);\n    }\n  }, {\n    key: 'delete',\n    value: function _delete(name) {\n      this._entries = this._entries.filter(function (entry) {\n        return entry[0] !== name;\n      });\n    }\n  }, {\n    key: 'get',\n    value: function get(name) {\n      var namedEntry = _.find(this._entries, function (entry) {\n        return entry[0] === name;\n      });\n      return namedEntry ? namedEntry[1] : null;\n    }\n  }, {\n    key: 'getAll',\n    value: function getAll(name) {\n      return this._entries.filter(function (entry) {\n        return entry[0] === name;\n      }).map(function (entry) {\n        return entry[1];\n      });\n    }\n  }, {\n    key: 'has',\n    value: function has(name) {\n      var namedEntry = _.find(this._entries, function (entry) {\n        return entry[0] === name;\n      });\n      return !!namedEntry;\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return _getIterator(this._entries);\n    }\n  }, {\n    key: '_asStream',\n    value: function _asStream(boundary) {\n      var iterator = _getIterator(this._entries);\n      var stream = new Stream.Readable();\n      stream._read = function () {\n        var next = iterator.next();\n        if (next.value) {\n          var _next$value = _slicedToArray(next.value, 2);\n\n          var _name3 = _next$value[0];\n          var value = _next$value[1];\n\n          this.push('--' + boundary + '\\r\\n');\n          if (value.read) {\n            var buffer = value.read();\n            this.push('Content-Disposition: form-data; name=\"' + _name3 + '\"; filename=\"' + value + '\"\\r\\n');\n            this.push('Content-Type: ' + (value.mime || 'application/octet-stream') + '\\r\\n');\n            this.push('Content-Length: ' + buffer.length + '\\r\\n');\n            this.push('\\r\\n');\n            this.push(buffer);\n          } else {\n            var text = value.toString('utf-8');\n            this.push('Content-Disposition: form-data; name=\"' + _name3 + '\"\\r\\n');\n            this.push('Content-Type: text/plain; charset=utf8\\r\\n');\n            this.push('Content-Length: ' + text.length + '\\r\\n');\n            this.push('\\r\\n');\n            this.push(text);\n          }\n          this.push('\\r\\n');\n        }\n        if (next.done) {\n          this.push('--' + boundary + '--');\n          this.push(null);\n        }\n      };\n      return stream;\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      return this._entries.length;\n    }\n  }]);\n\n  return FormData;\n})();\n\nvar Body = (function () {\n  function Body(bodyInit) {\n    _classCallCheck(this, Body);\n\n    if (bodyInit instanceof Body) {\n      this._stream = bodyInit._stream;\n      this._contentType = bodyInit.headers.get('Content-Type');\n    } else if (bodyInit instanceof Stream.Readable) {\n      // Request + Replay start streaming immediately, so we need this trick to\n      // buffer HTTP responses; this is likely a bug in Replay\n      this._stream = new Stream.PassThrough();\n      this._stream.pause();\n      bodyInit.pipe(this._stream);\n    } else if (typeof bodyInit === 'string' || bodyInit instanceof String) {\n      this._stream = new Stream.Readable();\n      this._stream._read = function () {\n        this.push(bodyInit);\n        this.push(null);\n      };\n      this._contentType = 'text/plain;charset=UTF-8';\n    } else if (bodyInit instanceof FormData && bodyInit.length) {\n      var boundary = new Date().getTime() + '.' + Math.random();\n      this._contentType = 'multipart/form-data;boundary=' + boundary;\n      this._stream = bodyInit._asStream(boundary);\n    } else if (bodyInit instanceof FormData) this._contentType = 'text/plain;charset=UTF-8';else if (bodyInit) throw new TypeError('This body type not yet supported');\n\n    this._bodyUsed = false;\n    this.body = null;\n  }\n\n  // https://fetch.spec.whatwg.org/#request-class\n\n  _createClass(Body, [{\n    key: 'arrayBuffer',\n    value: function arrayBuffer() {\n      var _this2 = this;\n\n      return this._consume().then(function (buffer) {\n        _this2.body = buffer;\n      }).then(function () {\n        var arrayBuffer = new Uint8Array(_this2.body.length);\n        for (var i = 0; i < _this2.body.length; ++i) {\n          arrayBuffer[i] = _this2.body[i];\n        }return arrayBuffer;\n      });\n    }\n  }, {\n    key: 'blob',\n    value: function blob() {\n      throw new Error('Not implemented yet');\n    }\n  }, {\n    key: 'formData',\n    value: function formData() {\n      var _this3 = this;\n\n      return this._consume().then(function (buffer) {\n        _this3.body = buffer;\n      }).then(function () {\n\n        var contentType = _this3.headers.get('Content-Type') || '';\n        var mimeType = contentType.split(';')[0];\n        switch (mimeType) {\n          case 'multipart/form-data':\n            {\n              throw new Error('Not implemented yet');\n            }\n          case 'application/x-www-form-urlencoded':\n            {\n              throw new Error('Not implemented yet');\n            }\n          default:\n            {\n              throw new TypeError('formData does not support MIME type ' + mimeType);\n            }\n        }\n      });\n    }\n  }, {\n    key: 'json',\n    value: function json() {\n      var _this4 = this;\n\n      return this._consume().then(function (buffer) {\n        _this4.body = buffer.toString('utf-8');\n      }).then(function () {\n        return JSON.parse(_this4.body);\n      });\n    }\n  }, {\n    key: 'text',\n    value: function text() {\n      var _this5 = this;\n\n      return this._consume().then(function (buffer) {\n        _this5.body = buffer.toString();\n      }).then(function () {\n        return _this5.body;\n      });\n    }\n\n    // -- Implementation details --\n\n  }, {\n    key: '_consume',\n    value: function _consume() {\n      if (this._bodyUsed) throw new TypeError('Body already consumed');\n      this._bodyUsed = true;\n\n      // When Request has no body, _stream is typically null\n      if (!this._stream) return null;\n      // When Response has no body, we get stream that's no longer readable\n      if (!this._stream.readable) return new Buffer('');\n\n      var decompressed = decompressStream(this._stream, this.headers);\n\n      return new _Promise(function (resolve, reject) {\n        var buffers = [];\n        decompressed.on('data', function (buffer) {\n          buffers.push(buffer);\n        }).on('end', function () {\n          resolve(Buffer.concat(buffers));\n        }).on('error', reject).resume();\n      });\n    }\n  }, {\n    key: 'bodyUsed',\n    get: function get() {\n      return this._bodyUsed;\n    }\n  }]);\n\n  return Body;\n})();\n\nvar Request = (function (_Body) {\n  _inherits(Request, _Body);\n\n  function Request(input, init) {\n    _classCallCheck(this, Request);\n\n    var method = ((init ? init.method : input.method) || 'GET').toUpperCase();\n    var bodyInit = null;\n\n    if (input instanceof Request && input._stream) {\n      if (input._bodyUsed) throw new TypeError('Request body already used');\n      bodyInit = input;\n      input._bodyUsed = true;\n    }\n\n    if (init && init.body) {\n      if (method === 'GET' || method === 'HEAD') throw new TypeError('Cannot include body with GET/HEAD request');\n      bodyInit = init.body;\n    }\n    _get(Object.getPrototypeOf(Request.prototype), 'constructor', this).call(this, bodyInit);\n\n    if (typeof input === 'string' || input instanceof String) this.url = URL.format(input);else if (input instanceof Request) this.url = input.url;\n    if (!this.url) throw new TypeError('Input must be string or another Request');\n\n    this.method = method;\n    this.headers = new Headers(init ? init.headers : input.headers);\n    if (this._contentType && !this.headers.has('Content-Type')) this.headers.set('Content-Type', this._contentType);\n\n    // Default redirect is follow, also treat manual as follow\n    this.redirect = init && init.redirect;\n    if (this.redirect !== 'error') this.redirect = 'follow';\n    this._redirectCount = 0;\n  }\n\n  // https://fetch.spec.whatwg.org/#response-class\n\n  // -- From Request interface --\n\n  _createClass(Request, [{\n    key: 'clone',\n    value: function clone() {\n      if (this._bodyUsed) throw new TypeError('This Request body has already been used');\n      throw new Error('Not implemented yet');\n    }\n\n    // -- From Body interface --\n\n  }]);\n\n  return Request;\n})(Body);\n\nvar Response = (function (_Body2) {\n  _inherits(Response, _Body2);\n\n  function Response(bodyInit, responseInit) {\n    _classCallCheck(this, Response);\n\n    _get(Object.getPrototypeOf(Response.prototype), 'constructor', this).call(this, bodyInit);\n    if (responseInit) {\n      if (responseInit.status < 200 || responseInit.status > 599) throw new RangeError('Status code ' + responseInit.status + ' not in range');\n      var statusText = responseInit.statusText || HTTP.STATUS_CODES[responseInit.status] || 'Unknown';\n      if (!/^[^\\n\\r]+$/.test(statusText)) throw new TypeError('Status text ' + responseInit.statusText + ' not valid format');\n\n      this._url = URL.format(responseInit.url || '');\n      this.type = 'default';\n      this.status = responseInit.status;\n      this.statusText = statusText;\n      this.headers = new Headers(responseInit.headers);\n    } else {\n      this.type = 'error';\n      this.status = 0;\n      this.statusText = '';\n      this.headers = new Headers();\n    }\n    if (this._contentType && !this.headers.has('Content-Type')) this.headers.set('Content-Type', this._contentType);\n  }\n\n  _createClass(Response, [{\n    key: 'clone',\n    value: function clone() {\n      if (this._bodyUsed) throw new TypeError('This Response body has already been used');\n      throw new Error('Not implemented yet');\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return (this._url || '').split('#')[0];\n    }\n  }, {\n    key: 'ok',\n    get: function get() {\n      return this.status >= 200 && this.status <= 299;\n    }\n  }], [{\n    key: 'error',\n    value: function error() {\n      return new Response();\n    }\n  }, {\n    key: 'redirect',\n    value: function redirect(url) {\n      var status = arguments.length <= 1 || arguments[1] === undefined ? 302 : arguments[1];\n\n      var parsedURL = URL.parse(url);\n      if ([301, 302, 303, 307, 308].indexOf(status) < 0) throw new RangeError('Status code ' + status + ' not valid redirect code');\n      var statusText = HTTP.STATUS_CODES[status];\n      var response = new Response(null, { status: status, statusText: statusText });\n      response.headers.set('Location', URL.format(parsedURL));\n      return response;\n    }\n  }]);\n\n  return Response;\n})(Body);\n\nmodule.exports = {\n  Headers: Headers,\n  FormData: FormData,\n  Request: Request,\n  Response: Response\n};\n//# sourceMappingURL=fetch.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/dom/index.js":"// Exports the JSDOM DOM living namespace.\n\n'use strict';\n\nvar DOM = require('jsdom/lib/jsdom/living');\nmodule.exports = DOM;\n\n// Monkey patching JSDOM.  This is why we can't have nice things.\nrequire('./focus');\nrequire('./iframe');\nrequire('./forms');\nrequire('./jsdom_patches');\nrequire('./scripts');\n//# sourceMappingURL=index.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/dom/focus.js":"// Support for element focus.\n\n'use strict';\n\nvar DOM = require('./index');\n\nvar FOCUS_ELEMENTS = ['INPUT', 'SELECT', 'TEXTAREA', 'BUTTON', 'ANCHOR'];\n\n// The element in focus.\n//\n// If no element has the focus, return the document.body.\nDOM.HTMLDocument.prototype.__defineGetter__('activeElement', function () {\n  return this._inFocus || this.body;\n});\n\n// Change the current element in focus (or null for blur)\nfunction setFocus(document, element) {\n  var inFocus = document._inFocus;\n  if (element !== inFocus) {\n    if (inFocus) {\n      var _onblur = document.createEvent('HTMLEvents');\n      _onblur.initEvent('blur', false, false);\n      inFocus.dispatchEvent(_onblur);\n    }\n    if (element) {\n      // null to blur\n      var _onfocus = document.createEvent('HTMLEvents');\n      _onfocus.initEvent('focus', false, false);\n      element.dispatchEvent(_onfocus);\n      document._inFocus = element;\n      document.defaultView.browser.emit('focus', element);\n    }\n  }\n}\n\n// All HTML elements have a no-op focus/blur methods.\nDOM.HTMLElement.prototype.focus = function () {};\nDOM.HTMLElement.prototype.blur = function () {};\n\n// Input controls have active focus/blur elements.  JSDOM implements these as\n// no-op, so we have to over-ride each prototype individually.\nvar CONTROLS = [DOM.HTMLInputElement, DOM.HTMLSelectElement, DOM.HTMLTextAreaElement, DOM.HTMLButtonElement, DOM.HTMLAnchorElement];\n\nCONTROLS.forEach(function (elementType) {\n  elementType.prototype.focus = function () {\n    setFocus(this.ownerDocument, this);\n  };\n\n  elementType.prototype.blur = function () {\n    setFocus(this.ownerDocument, null);\n  };\n\n  // Capture the autofocus element and use it to change focus\n  var setAttribute = elementType.prototype.setAttribute;\n  elementType.prototype.setAttribute = function (name, value) {\n    setAttribute.call(this, name, value);\n    if (name === 'autofocus') {\n      var _document = this.ownerDocument;\n      if (~FOCUS_ELEMENTS.indexOf(this.tagName) && !_document._inFocus) this.focus();\n    }\n  };\n});\n\n// When changing focus onto form control, store the current value.  When changing\n// focus to different control, if the value has changed, trigger a change event.\nvar INPUTS = [DOM.HTMLInputElement, DOM.HTMLTextAreaElement, DOM.HTMLSelectElement];\n\nINPUTS.forEach(function (elementType) {\n  elementType.prototype._eventDefaults.focus = function (event) {\n    var element = event.target;\n    element._focusValue = element.value || '';\n  };\n\n  elementType.prototype._eventDefaults.blur = function (event) {\n    var element = event.target;\n    var focusValue = element._focusValue;\n    if (focusValue !== element.value) {\n      // null == undefined\n      var change = element.ownerDocument.createEvent('HTMLEvents');\n      change.initEvent('change', false, false);\n      element.dispatchEvent(change);\n    }\n  };\n});\n//# sourceMappingURL=focus.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/dom/iframe.js":"// Support for iframes.\n\n'use strict';\n\nvar DOM = require('./index');\nvar resourceLoader = require('jsdom/lib/jsdom/browser/resource-loader');\n\nfunction loadFrame(frame) {\n  // Close current content window in order to open a new one\n  if (frame._contentWindow) {\n    frame._contentWindow.close();\n    delete frame._contentWindow;\n  }\n\n  function onload() {\n    frame.contentWindow.removeEventListener('load', onload);\n    var parentDocument = frame._ownerDocument;\n    var loadEvent = parentDocument.createEvent('HTMLEvents');\n    loadEvent.initEvent('load', false, false);\n    frame.dispatchEvent(loadEvent);\n  }\n\n  // This is both an accessor to the contentWindow and a side-effect of creating\n  // the window and loading the document based on the value of frame.src\n  //\n  // Not happy about this hack\n  frame.contentWindow.addEventListener('load', onload);\n}\n\nfunction refreshAccessors(document) {\n  var window = document._defaultView;\n  var frames = document.querySelectorAll('iframe,frame');\n  for (var i = 0; i < window._length; ++i) {\n    delete window[i];\n  }window._length = frames.length;\n  Array.prototype.forEach.call(frames, function (frame, i) {\n    window.__defineGetter__(i, function () {\n      return frame.contentWindow;\n    });\n  });\n}\n\nfunction refreshNameAccessor(frame) {\n  var name = frame.getAttribute('name');\n  // https://html.spec.whatwg.org/multipage/browsers.html#named-access-on-the-window-object:supported-property-names\n  if (name) {\n    // I do not know why this only works with _global and not with _defaultView :(\n    var _window = frame._ownerDocument._global;\n    delete _window[name];\n    if (isInDocument(frame)) _window.__defineGetter__(name, function () {\n      return frame.contentWindow;\n    });\n  }\n}\n\nfunction isInDocument(el) {\n  var document = el._ownerDocument;\n  var current = el;\n  while (current = current.parentNode) if (current === document) return true;\n  return false;\n}\n\nDOM.HTMLFrameElement.prototype._attrModified = function (name, value, oldVal) {\n  DOM.HTMLElement.prototype._attrModified.call(this, name, value, oldVal);\n  if (name === 'name') {\n    if (oldVal)\n      // I do not know why this only works with _global and not with _defaultView :(\n      delete this._ownerDocument._global[oldVal];\n    refreshNameAccessor(this);\n  } else if (name === 'src' && value !== oldVal && isInDocument(this)) loadFrame(this);\n};\n\nDOM.HTMLFrameElement.prototype._detach = function () {\n  DOM.HTMLElement.prototype._detach.call(this);\n  if (this.contentWindow) this.contentWindow.close();\n  refreshAccessors(this._ownerDocument);\n  refreshNameAccessor(this);\n};\n\nDOM.HTMLFrameElement.prototype._attach = function () {\n  DOM.HTMLElement.prototype._attach.call(this);\n  loadFrame(this);\n  refreshAccessors(this._ownerDocument);\n  refreshNameAccessor(this);\n};\n\nDOM.HTMLFrameElement.prototype.__defineGetter__('contentDocument', function () {\n  return this.contentWindow.document;\n});\n\nDOM.HTMLFrameElement.prototype.__defineGetter__('contentWindow', function () {\n  var _this = this;\n\n  if (!this._contentWindow) {\n    var createHistory = require('../history');\n    var parentDocument = this._ownerDocument;\n    var parentWindow = parentDocument.defaultView;\n\n    // Need to bypass JSDOM's window/document creation and use ours\n    var openWindow = createHistory(parentWindow.browser, function (active) {\n      // Change the focus from window to active.\n      _this._contentWindow = active;\n    });\n\n    var src = this.src.trim() === '' ? 'about:blank' : this.src;\n    this._contentWindow = openWindow({\n      name: this.name,\n      url: resourceLoader.resolveResourceUrl(parentDocument, src),\n      parent: parentWindow,\n      referrer: parentWindow.location.href\n    });\n  }\n  return this._contentWindow;\n});\n//# sourceMappingURL=iframe.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/dom/forms.js":"// Patches to JSDOM for properly handling forms.\n'use strict';\n\nvar _Map = require('babel-runtime/core-js/map')['default'];\n\nvar _Array$from = require('babel-runtime/core-js/array/from')['default'];\n\nvar _Object$assign = require('babel-runtime/core-js/object/assign')['default'];\n\nvar DOM = require('./index');\nvar File = require('fs');\nvar Mime = require('mime');\nvar Path = require('path');\n\n// The Form\n// --------\n\n// Forms convert INPUT fields of type file into this object and pass it as\n// parameter to resource request.\n//\n// The base class is a String, so the value (e.g. when passed in a GET request)\n// is the base filename.  Additional properties include the MIME type (`mime`),\n// the full filename (`filename`) and the `read` method that returns the file\n// contents.\nfunction uploadedFile(filename) {\n  var file = {\n    valueOf: function valueOf() {\n      return Path.basename(filename);\n    }\n  };\n  file.filename = filename;\n  file.mime = Mime.lookup(filename);\n  file.read = function () {\n    return File.readFileSync(filename);\n  };\n  return file;\n}\n\n// Implement form.submit such that it actually submits a request to the server.\n// This method takes the submitting button so we can send the button name/value.\nDOM.HTMLFormElement.prototype.submit = function (button) {\n  var form = this;\n  var document = form.ownerDocument;\n  var params = new _Map();\n\n  function addFieldValues(fieldName, values) {\n    var current = params.get(fieldName) || [];\n    var next = current.concat(values);\n    params.set(fieldName, next);\n  }\n\n  function addFieldToParams(field) {\n    if (field.getAttribute('disabled')) return;\n\n    var name = field.getAttribute('name');\n    if (!name) return;\n\n    if (field.nodeName === 'SELECT') {\n      var selected = _Array$from(field.options).filter(function (option) {\n        return option.selected;\n      }).map(function (options) {\n        return options.value;\n      });\n\n      if (field.multiple) addFieldValues(name, selected);else {\n        var value = selected.length > 0 ? selected[0] : field.options.length && field.options[0].value;\n        addFieldValues(name, [value]);\n      }\n      return;\n    }\n\n    if (field.nodeName === 'INPUT' && (field.type === 'checkbox' || field.type === 'radio')) {\n      if (field.checked) {\n        var value = field.value || '1';\n        addFieldValues(name, [value]);\n      }\n      return;\n    }\n\n    if (field.nodeName === 'INPUT' && field.type === 'file') {\n      if (field.value) {\n        var value = uploadedFile(field.value);\n        addFieldValues(name, [value]);\n      }\n      return;\n    }\n\n    if (field.nodeName === 'TEXTAREA' || field.nodeName === 'INPUT') {\n      if (field.type !== 'submit' && field.type !== 'image') addFieldValues(name, [field.value]);\n      return;\n    }\n  }\n\n  function addButtonToParams() {\n    if (button.nodeName === 'INPUT' && button.type === 'image') {\n      addFieldValues(button.name + '.x', ['0']);\n      addFieldValues(button.name + '.y', ['0']);\n\n      if (button.value) addFieldValues(button.name, [button.value]);\n    } else addFieldValues(button.name, [button.value]);\n  }\n\n  function submit() {\n    if (button && button.name) addButtonToParams();\n\n    // Ask window to submit form, let it figure out how to handle this based on\n    // the target attribute.\n    document.defaultView._submit({\n      url: form.getAttribute('action') || document.location.href,\n      method: form.getAttribute('method') || 'GET',\n      encoding: form.getAttribute('enctype'),\n      params: params,\n      target: form.getAttribute('target')\n    });\n  }\n\n  function process(index) {\n    var field = form.elements.item(index);\n    if (!field) {\n      submit();\n      return;\n    }\n    addFieldToParams(field);\n    process(index + 1);\n  }\n\n  process(0);\n};\n\n// Replace dispatchEvent so we can send the button along the event.\nDOM.HTMLFormElement.prototype._dispatchSubmitEvent = function (button) {\n  var event = this.ownerDocument.createEvent('HTMLEvents');\n  event.initEvent('submit', true, true);\n  event._button = button;\n  return this.dispatchEvent(event);\n};\n\n// Default behavior for submit events is to call the form's submit method, but we\n// also pass the submitting button.\nDOM.HTMLFormElement.prototype._eventDefaults.submit = function (event) {\n  event.target.submit(event._button);\n};\n\n// Buttons\n// -------\n\n// Default behavior for clicking on inputs.\nDOM.HTMLInputElement.prototype._eventDefaults = _Object$assign({}, DOM.HTMLElement.prototype._eventDefaults);\n\nDOM.HTMLInputElement.prototype._eventDefaults.click = function (event) {\n  var input = event.target;\n\n  function change() {\n    var changeEvent = input.ownerDocument.createEvent('HTMLEvents');\n    changeEvent.initEvent('change', true, true);\n    input.dispatchEvent(changeEvent);\n  }\n\n  switch (input.type) {\n    case 'reset':\n      {\n        if (input.form) input.form.reset();\n        break;\n      }\n    case 'submit':\n      {\n        if (input.form) input.form._dispatchSubmitEvent(input);\n        break;\n      }\n    case 'image':\n      {\n        if (input.form) input.form._dispatchSubmitEvent(input);\n        break;\n      }\n    case 'checkbox':\n      {\n        change();\n        break;\n      }\n    case 'radio':\n      {\n        if (!input.getAttribute('readonly')) {\n          input.checked = true;\n          change();\n        }\n      }\n  }\n};\n\n// Current INPUT behavior on click is to capture sumbit and handle it, but\n// ignore all other clicks. We need those other clicks to occur, so we're going\n// to dispatch them all.\nDOM.HTMLInputElement.prototype.click = function () {\n  var _this = this;\n\n  var input = this;\n  input.focus();\n\n  // First event we fire is click event\n  function click() {\n    var clickEvent = input.ownerDocument.createEvent('HTMLEvents');\n    clickEvent.initEvent('click', true, true);\n    return input.dispatchEvent(clickEvent);\n  }\n\n  switch (input.type) {\n    case 'checkbox':\n      {\n        if (input.getAttribute('readonly')) break;\n\n        var original = input.checked;\n        input.checked = !original;\n        var checkResult = click();\n        if (checkResult === false) input.checked = original;\n        break;\n      }\n\n    case 'radio':\n      {\n        if (input.getAttribute('readonly')) break;\n\n        if (input.checked) click();else {\n          (function () {\n            var radios = input.ownerDocument.querySelectorAll('input[type=radio][name=\\'' + _this.getAttribute('name') + '\\']');\n            var checked = _Array$from(radios).filter(function (radio) {\n              return radio.checked && radio.form === _this.form;\n            }).map(function (radio) {\n              radio.checked = false;\n            })[0];\n\n            input.checked = true;\n            var radioResult = click();\n            if (radioResult === false) {\n              input.checked = false;\n              _Array$from(radios).filter(function (radio) {\n                return radio.form === input.form;\n              }).forEach(function (radio) {\n                radio.checked = radio === checked;\n              });\n            }\n          })();\n        }\n        break;\n      }\n\n    default:\n      {\n        click();\n        break;\n      }\n  }\n};\n\n// Default behavior for form BUTTON: submit form.\nDOM.HTMLButtonElement.prototype._eventDefaults.click = function (event) {\n  var button = event.target;\n  if (button.getAttribute('disabled')) return false;\n\n  var form = button.form;\n  if (form) return form._dispatchSubmitEvent(button);\n};\n//# sourceMappingURL=forms.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/dom/jsdom_patches.js":"// Fix things that JSDOM doesn't do quite right.\n\n'use strict';\n\nvar _Object$assign = require('babel-runtime/core-js/object/assign')['default'];\n\nvar _Number$isFinite = require('babel-runtime/core-js/number/is-finite')['default'];\n\nvar DOM = require('./index');\nvar Fetch = require('../fetch');\nvar resourceLoader = require('jsdom/lib/jsdom/browser/resource-loader');\nvar Utils = require('jsdom/lib/jsdom/utils');\nvar URL = require('url');\nvar createHTMLColection = require('jsdom/lib/jsdom/living/html-collection').create;\n\nDOM.HTMLDocument.prototype.__defineGetter__('scripts', function () {\n  var _this = this;\n\n  return createHTMLColection(this, function () {\n    return _this.querySelectorAll('script');\n  });\n});\n\n// Default behavior for clicking on links: navigate to new URL if specified.\nDOM.HTMLAnchorElement.prototype._eventDefaults = _Object$assign({}, DOM.HTMLElement.prototype._eventDefaults);\nDOM.HTMLAnchorElement.prototype._eventDefaults.click = function (event) {\n  var anchor = event.target;\n  if (!anchor.href) return;\n\n  var window = anchor.ownerDocument.defaultView;\n  var browser = window.browser;\n\n  // Decide which window to open this link in\n  switch (anchor.target || '_self') {\n    case '_self':\n      {\n        // navigate same window\n        window.location = anchor.href;\n        break;\n      }\n    case '_parent':\n      {\n        // navigate parent window\n        window.parent.location = anchor.href;\n        break;\n      }\n    case '_top':\n      {\n        // navigate top window\n        window.top.location = anchor.href;\n        break;\n      }\n    default:\n      {\n        // open named window\n        browser.tabs.open({ name: anchor.target, url: anchor.href });\n        break;\n      }\n  }\n  browser.emit('link', anchor.href, anchor.target || '_self');\n};\n\n// Attempt to load the image, this will trigger a 'load' event when succesful\n// jsdom seemed to only queue the 'load' event\nDOM.HTMLImageElement.prototype._attrModified = function (name, value, oldVal) {\n  if (name === 'src' && value && value !== oldVal) resourceLoader.load(this, value);\n  DOM.HTMLElement.prototype._attrModified.call(this, name, value, oldVal);\n};\n\n// Implement getClientRects\nDOM.HTMLElement.prototype.getClientRects = function () {\n  var style = this.style;\n\n  if (style && style.display === 'none') {\n    return [];\n  }\n\n  return [{\n    bottom: 0,\n    height: 0,\n    left: 0,\n    right: 0,\n    top: 0,\n    width: 0\n  }];\n};\n\nObject.defineProperty(DOM.HTMLElement.prototype, 'offsetHeight', {\n  get: function get() {\n    return 0;\n  }\n});\n\nObject.defineProperty(DOM.HTMLElement.prototype, 'offsetWidth', {\n  get: function get() {\n    return 0;\n  }\n});\n\n// Implement insertAdjacentHTML\nDOM.HTMLElement.prototype.insertAdjacentHTML = function (position, html) {\n  var parentNode = this.parentNode;\n\n  var container = this.ownerDocument.createElementNS('http://www.w3.org/1999/xhtml', '_');\n  container.innerHTML = html;\n\n  switch (position.toLowerCase()) {\n    case 'beforebegin':\n      {\n        while (container.firstChild) parentNode.insertBefore(container.firstChild, this);\n        break;\n      }\n    case 'afterbegin':\n      {\n        var firstChild = this.firstChild;\n        while (container.lastChild) firstChild = this.insertBefore(container.lastChild, firstChild);\n        break;\n      }\n    case 'beforeend':\n      {\n        while (container.firstChild) this.appendChild(container.firstChild);\n        break;\n      }\n    case 'afterend':\n      {\n        var nextSibling = this.nextSibling;\n        while (container.lastChild) nextSibling = parentNode.insertBefore(container.lastChild, nextSibling);\n        break;\n      }\n  }\n};\n\n// Implement documentElement.contains\n// e.g., if(document.body.contains(el)) { ... }\n// See https://developer.mozilla.org/en-US/docs/DOM/Node.contains\nDOM.Node.prototype.contains = function (otherNode) {\n  // DDOPSON-2012-08-16 -- This implementation is stolen from Sizzle's\n  // implementation of 'contains' (around line 1402).\n  // We actually can't call Sizzle.contains directly:\n  // * Because we define Node.contains, Sizzle will configure it's own\n  //   \"contains\" method to call us. (it thinks we are a native browser\n  //   implementation of \"contains\")\n  // * Thus, if we called Sizzle.contains, it would form an infinite loop.\n  //   Instead we use Sizzle's fallback implementation of \"contains\" based on\n  //   \"compareDocumentPosition\".\n  return !!(this.compareDocumentPosition(otherNode) & 16);\n};\n\n// Support for opacity style property.\nObject.defineProperty(DOM.CSSStyleDeclaration.prototype, 'opacity', {\n  get: function get() {\n    var opacity = this.getPropertyValue('opacity');\n    return _Number$isFinite(opacity) ? opacity.toString() : '';\n  },\n\n  set: function set(opacity) {\n    if (opacity === null || opacity === undefined || opacity === '') this.removeProperty('opacity');else {\n      var value = parseFloat(opacity);\n      if (isFinite(value)) this._setProperty('opacity', value);\n    }\n  }\n});\n\n// Wrap dispatchEvent to support _windowInScope and error handling.\nvar jsdomDispatchEvent = DOM.EventTarget.prototype.dispatchEvent;\nDOM.EventTarget.prototype.dispatchEvent = function (event) {\n  // Could be node, window or document\n  var document = this._ownerDocument || this.document || this;\n  var window = document.defaultView;\n  // Fail miserably on objects that don't have ownerDocument: nodes and XHR\n  // request have those\n  var browser = window.browser;\n\n  browser.emit('event', event, this);\n\n  var originalInScope = browser._windowInScope;\n  try {\n    // The current window, postMessage and window.close need this\n    browser._windowInScope = window;\n    // Inline event handlers rely on window.event\n    window.event = event;\n    return jsdomDispatchEvent.call(this, event);\n  } finally {\n    delete window.event;\n    browser._windowInScope = originalInScope;\n  }\n};\n\n// Fix resource loading to keep track of in-progress requests. Need this to wait\n// for all resources (mainly JavaScript) to complete loading before terminating\n// browser.wait.\nresourceLoader.load = function (element, href, callback) {\n  var _this2 = this;\n\n  var document = element.ownerDocument;\n  var window = document.defaultView;\n  var tagName = element.tagName.toLowerCase();\n  var loadResource = document.implementation._hasFeature('FetchExternalResources', tagName);\n  var url = resourceLoader.resolveResourceUrl(document, href);\n\n  if (loadResource) {\n    (function () {\n      // This guarantees that all scripts are executed in order, must add to the\n      // JSDOM queue before we add to the Zombie event queue.\n      var enqueued = _this2.enqueue(element, url, callback && callback.bind(element));\n      var request = new Fetch.Request(url);\n      window._eventQueue.http(request, function (error, response) {\n        // Since this is used by resourceLoader that doesn't check the response,\n        // we're responsible to turn anything other than 2xx/3xx into an error\n        if (error) enqueued(new Error('Network error'));else if (response.status >= 400) enqueued(new Error('Server returned status code ' + response.status + ' from ' + url));else response._consume().then(function (buffer) {\n          response.body = buffer;\n          enqueued(null, buffer);\n        });\n      });\n    })();\n  }\n};\n\n// Fix residual Node bug. See https://github.com/joyent/node/pull/14146\nvar jsdomResolveHref = Utils.resolveHref;\nUtils.resolveHref = function (baseUrl, href) {\n  var pattern = /file:?/;\n  var protocol = URL.parse(baseUrl).protocol;\n  var original = URL.parse(href);\n  var resolved = URL.parse(jsdomResolveHref(baseUrl, href));\n\n  if (!pattern.test(protocol) && pattern.test(original.protocol) && !original.host && resolved.host) return URL.format(original);else return URL.format(resolved);\n};\n//# sourceMappingURL=jsdom_patches.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/dom/scripts.js":"// For handling JavaScript, mostly improvements to JSDOM\n\n'use strict';\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar DOM = require('./index');\nvar resourceLoader = require('jsdom/lib/jsdom/browser/resource-loader');\nvar reportException = require('jsdom/lib/jsdom/living/helpers/runtime-script-errors');\n\n// -- Patches to JSDOM --\n\n// If JSDOM encounters a JS error, it fires on the element.  We expect it to be\n// fires on the Window.  We also want better stack traces.\nDOM.languageProcessors.javascript = function (element, buffer, filename) {\n  var code = buffer.toString();\n  // This may be called without code, e.g. script element that has no body yet\n  if (!code) return;\n\n  // Surpress JavaScript validation and execution\n  var document = element.ownerDocument;\n  var window = document.defaultView;\n  var browser = window.top.browser;\n  if (browser && !browser.runScripts) return;\n\n  // This may be called without code, e.g. script element that has no body yet\n  try {\n    window.document._currentScript = element;\n    window._evaluate(code, filename);\n  } catch (error) {\n    enhanceStackTrace(error, document.location.href);\n    reportException(window, error);\n  } finally {\n    window.document._currentScript = null;\n  }\n};\n\nfunction enhanceStackTrace(error, document_ref) {\n  var partial = [];\n  // \"RangeError: Maximum call stack size exceeded\" doesn't have a stack trace\n  if (error.stack) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _getIterator(error.stack.split('\\n')), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var line = _step.value;\n\n        if (~line.indexOf('vm.js')) break;\n        partial.push(line);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator['return']) {\n          _iterator['return']();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }partial.push('    in ' + document_ref);\n  error.stack = partial.join('\\n');\n  return error;\n}\n\n// HTML5 parser doesn't play well with JSDOM so we need this trickey to sort of\n// get script execution to work properly.\n//\n// Basically JSDOM listend for when the script tag is added to the DOM and\n// attemps to evaluate at, but the script has no contents at that point in\n// time.  This adds just enough delay for the inline script's content to be\n// parsed and ready for processing.\nDOM.HTMLScriptElement._init = function () {\n  this.addEventListener('DOMNodeInsertedIntoDocument', function () {\n    var script = this;\n    var document = script.ownerDocument;\n\n    if (script.src)\n      // Script has a src attribute, load external resource.\n      resourceLoader.load(script, script.src, script._eval);else {\n      var filename = script.id ? document.URL + ':#' + script.id : document.URL + ':script';\n      // Queue to be executed in order with all other scripts\n      var executeInOrder = resourceLoader.enqueue(script, filename, executeInlineScript);\n      // There are two scenarios:\n      // - script element added to existing document, we should evaluate it\n      //   immediately\n      // - inline script element parsed, when we get here, we still don't have\n      //   the element contents, so we have to wait before we can read and\n      //   execute it\n      if (document.readyState === 'loading') process.nextTick(executeInOrder);else executeInOrder();\n    }\n\n    // Execute inline script\n    function executeInlineScript(code, filename) {\n      script._eval(script.textContent, filename);\n    }\n  });\n};\n//# sourceMappingURL=scripts.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/resources.js":"// History of resources loaded by window.\n\n'use strict';\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _get = require('babel-runtime/helpers/get')['default'];\n\nvar _inherits = require('babel-runtime/helpers/inherits')['default'];\n\nvar _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar Fetch = require('./fetch');\n\n// Each resource is associated with request, and on completion response or error.\n\nvar Resource = (function () {\n  function Resource(_ref) {\n    var request = _ref.request;\n\n    _classCallCheck(this, Resource);\n\n    this.request = request;\n    this.error = null;\n    this.response = null;\n  }\n\n  // Each window has a resources object that provides the means for retrieving\n  // resources and a list of all retrieved resources.\n  //\n  // The object is an array, and its elements are the resources.\n\n  // The URL of this resource\n\n  _createClass(Resource, [{\n    key: 'dump',\n\n    // Dump the resource to output stream/stdout\n    value: function dump() {\n      var output = arguments.length <= 0 || arguments[0] === undefined ? process.stdout : arguments[0];\n      var request = this.request;\n      var response = this.response;\n      var error = this.error;\n\n      // Write summary request/response header\n      if (response) {\n        var elapsed = response.time - request.time;\n        output.write(request.method + ' ' + this.url + ' - ' + response.status + ' ' + response.statusText + ' - ' + elapsed + 'ms\\n');\n      } else output.write(request.method + ' ' + this.url + '\\n');\n\n      // If response, write out response headers and sample of document entity\n      // If error, write out the error message\n      // Otherwise, indicate this is a pending request\n      if (response) {\n        if (response._redirectCount) output.write('  Followed ' + response._redirectCount + ' redirects\\n');\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = _getIterator(response.headers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _step$value = _slicedToArray(_step.value, 2);\n\n            var _name = _step$value[0];\n            var value = _step$value[1];\n\n            output.write('  ' + _name + ': ' + value + '\\n');\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator['return']) {\n              _iterator['return']();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        output.write('\\n');\n        var sample = response.body.slice(0, 250).toString('utf8').split('\\n').map(function (line) {\n          return '  ' + line;\n        }).join('\\n');\n        output.write(sample);\n      } else if (error) output.write('  Error: ' + error.message + '\\n');else output.write('  Pending since ' + new Date(request.time) + '\\n');\n      // Keep them separated\n      output.write('\\n\\n');\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return this.response && this.response.url || this.request.url;\n    }\n  }]);\n\n  return Resource;\n})();\n\nvar Resources = (function (_Array) {\n  _inherits(Resources, _Array);\n\n  function Resources(window) {\n    _classCallCheck(this, Resources);\n\n    _get(Object.getPrototypeOf(Resources.prototype), 'constructor', this).call(this);\n    this._browser = window.browser;\n  }\n\n  _createClass(Resources, [{\n    key: '_fetch',\n    value: function _fetch(input, init) {\n      var pipeline = this._browser.pipeline;\n      var request = new Fetch.Request(input, init);\n      var resource = new Resource({ request: request });\n      this.push(resource);\n\n      return pipeline._fetch(request).then(function (response) {\n        resource.response = response;\n        return response;\n      })['catch'](function (error) {\n        resource.error = error;\n        resource.response = Fetch.Response.error();\n        throw error;\n      });\n    }\n\n    // Human readable resource listing.\n    //\n    // output - Write to this stream (optional)\n  }, {\n    key: 'dump',\n    value: function dump() {\n      var output = arguments.length <= 0 || arguments[0] === undefined ? process.stdout : arguments[0];\n\n      if (this.length === 0) output.write('No resources\\n');else this.forEach(function (resource) {\n        return resource.dump(output);\n      });\n    }\n  }]);\n\n  return Resources;\n})(Array);\n\nmodule.exports = Resources;\n//# sourceMappingURL=resources.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/xhr.js":"// Implements XMLHttpRequest.\n// See http://www.w3.org/TR/XMLHttpRequest/#the-abort()-method\n\n'use strict';\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar DOM = require('./dom');\nvar Fetch = require('./fetch');\nvar ms = require('ms');\nvar URL = require('url');\nvar Utils = require('jsdom/lib/jsdom/utils');\nvar EventTarget = require('jsdom/lib/jsdom/living/generated/EventTarget');\n\nvar DOMException = DOM.DOMException;\n\nvar XMLHttpRequest = (function () {\n  //class XMLHttpRequest extends EventTarget {\n\n  function XMLHttpRequest(window) {\n    _classCallCheck(this, XMLHttpRequest);\n\n    //super();\n    EventTarget.setup(this);\n    for (var method in EventTarget['interface'].prototype) {\n      this[method] = EventTarget['interface'].prototype[method];\n    }this._window = window;\n    this._browser = window.browser;\n    // Pending request\n    this._pending = null;\n    // Response headers\n    this.readyState = XMLHttpRequest.UNSENT;\n\n    this.onreadystatechange = null;\n    this.timeout = 0;\n\n    // XHR events need the first to dispatch, the second to propagate up to window\n    this._ownerDocument = window.document;\n  }\n\n  // Lifecycle states\n\n  // Aborts the request if it has already been sent.\n\n  _createClass(XMLHttpRequest, [{\n    key: 'abort',\n    value: function abort() {\n      var request = this._pending;\n      var sent = !!request;\n      if (this.readyState === XMLHttpRequest.UNSENT || this.readyState === XMLHttpRequest.OPENED && !sent) {\n        this.readyState = XMLHttpRequest.UNSENT;\n        return;\n      }\n      // Aborting a done request sets its readyState to UNSENT and does not trigger a readystatechange event\n      // https://xhr.spec.whatwg.org/#the-abort()-method\n      if (this.readyState === XMLHttpRequest.DONE) {\n        this.readyState = XMLHttpRequest.UNSENT;\n      } else {\n        // Tell any pending request it has been aborted.\n        request.aborted = true;\n      }\n      this._response = null;\n      this._error = null;\n      this._pending = null;\n    }\n\n    // Initializes a request.\n    //\n    // Calling this method an already active request (one for which open()or\n    // openRequest()has already been called) is the equivalent of calling abort().\n  }, {\n    key: 'open',\n    value: function open(method, url, useAsync, user, password) {\n      // jshint ignore:line\n      if (useAsync === false) throw new DOMException(DOMException.NOT_SUPPORTED_ERR, 'Zombie does not support synchronous XHR requests');\n\n      // Abort any pending request.\n      this.abort();\n\n      // Check supported HTTP method\n      this._method = method.toUpperCase();\n      if (/^(CONNECT|TRACE|TRACK)$/.test(this._method)) throw new DOMException(DOMException.SECURITY_ERR, 'Unsupported HTTP method');\n      if (!/^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/.test(this._method)) throw new DOMException(DOMException.SYNTAX_ERR, 'Unsupported HTTP method');\n\n      var headers = new Fetch.Headers();\n\n      // Normalize the URL and check security\n      url = URL.parse(Utils.resolveHref(this._window.location.href, url));\n      // Don't consider port if they are standard for http and https\n      if (url.protocol === 'https:' && url.port === '443' || url.protocol === 'http:' && url.port === '80') delete url.port;\n\n      if (!/^https?:$/i.test(url.protocol)) throw new DOMException(DOMException.NOT_SUPPORTED_ERR, 'Only HTTP/S protocol supported');\n      url.hostname = url.hostname || this._window.location.hostname;\n      url.host = url.port ? url.hostname + ':' + url.port : url.hostname;\n      if (url.host !== this._window.location.host) {\n        headers.set('Origin', this._window.location.protocol + '//' + this._window.location.host);\n        this._cors = headers.get('Origin');\n      }\n      url.hash = null;\n      if (user) url.auth = user + ':' + password;\n      // Used for logging requests\n      this._url = URL.format(url);\n      this._headers = headers;\n\n      // Reset response status\n      this._stateChanged(XMLHttpRequest.OPENED);\n    }\n\n    // Sets the value of an HTTP request header.You must call setRequestHeader()\n    // after open(), but before send().\n  }, {\n    key: 'setRequestHeader',\n    value: function setRequestHeader(header, value) {\n      if (this.readyState !== XMLHttpRequest.OPENED) throw new DOMException(DOMException.INVALID_STATE_ERR, 'Invalid state');\n      this._headers.set(header, value);\n    }\n\n    // Sends the request. If the request is asynchronous (which is the default),\n    // this method returns as soon as the request is sent. If the request is\n    // synchronous, this method doesn't return until the response has arrived.\n  }, {\n    key: 'send',\n    value: function send(data) {\n      var _this = this;\n\n      // Request must be opened.\n      if (this.readyState !== XMLHttpRequest.OPENED) throw new DOMException(DOMException.INVALID_STATE_ERR, 'Invalid state');\n\n      var request = new Fetch.Request(this._url, {\n        method: this._method,\n        headers: this._headers,\n        body: data\n      });\n      this._pending = request;\n      this._fire('loadstart');\n\n      var timeout = setTimeout(function () {\n        if (_this._pending === request) _this._pending = null;\n        request.timedOut = true;\n\n        _this._stateChanged(XMLHttpRequest.DONE);\n        _this._fire('progress');\n        _this._error = new DOMException(DOMException.TIMEOUT_ERR, 'The request timed out');\n        _this._fire('timeout', _this._error);\n        _this._fire('loadend');\n        _this._browser.errors.push(_this._error);\n      }, this.timeout || ms('2m'));\n\n      this._window._eventQueue.http(request, function (error, response) {\n        // Request already timed-out, nothing to do\n        if (request.timedOut) return;\n        clearTimeout(timeout);\n\n        if (_this._pending === request) _this._pending = null;\n\n        // Request aborted\n        if (request.aborted) {\n          _this._stateChanged(XMLHttpRequest.DONE);\n          _this._fire('progress');\n          _this._error = new DOMException(DOMException.ABORT_ERR, 'Request aborted');\n          _this._fire('abort', _this._error);\n          return;\n        }\n\n        // If not aborted, then we look at networking error\n        if (error) {\n          _this._stateChanged(XMLHttpRequest.DONE);\n          _this._fire('progress');\n          _this._error = new DOMException(DOMException.NETWORK_ERR);\n          _this._fire('error', _this._error);\n          _this._fire('loadend');\n          _this._browser.errors.push(_this._error);\n          return;\n        }\n\n        // CORS request, check origin, may lead to new error\n        if (_this._cors) {\n          var allowedOrigin = response.headers.get('Access-Control-Allow-Origin');\n          if (!(allowedOrigin === '*' || allowedOrigin === _this._cors)) {\n            _this._error = new DOMException(DOMException.SECURITY_ERR, 'Cannot make request to different domain');\n            _this._browser.errors.push(_this._error);\n            _this._stateChanged(XMLHttpRequest.DONE);\n            _this._fire('progress');\n            _this._fire('error', _this._error);\n            _this._fire('loadend');\n            _this.raise('error', _this._error.message, { exception: _this._error });\n            return;\n          }\n        }\n\n        // Store the response so getters have acess access it\n        _this._response = response;\n        // We have a one-stop implementation that goes through all the state\n        // transitions\n        _this._stateChanged(XMLHttpRequest.HEADERS_RECEIVED);\n        _this._stateChanged(XMLHttpRequest.LOADING);\n\n        var done = _this._window._eventQueue.waitForCompletion();\n        response.text().then(function (text) {\n          _this.responseText = text;\n          _this._stateChanged(XMLHttpRequest.DONE);\n\n          _this._fire('progress');\n          _this._fire('load');\n          _this._fire('loadend');\n          done();\n        });\n      });\n      request.sent = true;\n    }\n  }, {\n    key: 'getResponseHeader',\n    value: function getResponseHeader(name) {\n      // Returns the string containing the text of the specified header, or null if\n      // either the response has not yet been received or the header doesn't exist in\n      // the response.\n      return this._response && this._response.headers.get(name) || null;\n    }\n  }, {\n    key: 'getAllResponseHeaders',\n    value: function getAllResponseHeaders() {\n      // Returns all the response headers as a string, or null if no response has\n      // been received. Note: For multipart requests, this returns the headers from\n      // the current part of the request, not from the original channel.\n      if (this._response)\n        // XHR's getAllResponseHeaders, against all reason, returns a multi-line\n        // string.  See http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method\n        return this._response.headers.toString();else return null;\n    }\n\n    // Fire onreadystatechange event\n  }, {\n    key: '_stateChanged',\n    value: function _stateChanged(newState) {\n      this.readyState = newState;\n      this._fire('readystatechange');\n    }\n\n    // Fire the named event on this object\n  }, {\n    key: '_fire',\n    value: function _fire(eventName, error) {\n      var event = new DOM.Event('xhr');\n      event.initEvent(eventName, true, true);\n      event.error = error;\n      this.dispatchEvent(event);\n      this._browser.emit('xhr', eventName, this._url);\n    }\n\n    // Raise error coming from jsdom\n  }, {\n    key: 'raise',\n    value: function raise(type, message, data) {\n      this._ownerDocument.raise(type, message, data);\n    }\n  }, {\n    key: 'status',\n    get: function get() {\n      // Status code/headers available immediately, 0 if request errored\n      return this._response ? this._response.status : this._error ? 0 : null;\n    }\n  }, {\n    key: 'statusText',\n    get: function get() {\n      // Status code/headers available immediately, '' if request errored\n      return this._response ? this._response.statusText : this._error ? '' : null;\n    }\n  }, {\n    key: 'responseXML',\n    get: function get() {\n      // Not implemented yet\n      return null;\n    }\n  }]);\n\n  return XMLHttpRequest;\n})();\n\nXMLHttpRequest.UNSENT = 0;\nXMLHttpRequest.OPENED = 1;\nXMLHttpRequest.HEADERS_RECEIVED = 2;\nXMLHttpRequest.LOADING = 3;\nXMLHttpRequest.DONE = 4;\n\nmodule.exports = XMLHttpRequest;\n//# sourceMappingURL=xhr.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/console.js":"// Implements console.log, console.error, console.time, et al and emits a\n// console event for each output.\n\n'use strict';\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _Map = require('babel-runtime/core-js/map')['default'];\n\nvar _require = require('util');\n\nvar format = _require.format;\nvar inspect = _require.inspect;\n\nmodule.exports = (function () {\n  function Console(browser) {\n    _classCallCheck(this, Console);\n\n    this.browser = browser;\n    this.counters = new _Map();\n    this.timers = new _Map();\n  }\n\n  _createClass(Console, [{\n    key: 'assert',\n    value: function assert(truth) {\n      if (truth) return;\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var formatted = format.apply(undefined, [''].concat(args));\n      var message = 'Assertion failed: ' + (formatted || 'false');\n      this.browser.emit('console', 'error', message);\n      throw new Error(message);\n    }\n  }, {\n    key: 'count',\n    value: function count(name) {\n      var current = this.counters.get(name) || 0;\n      var next = current + 1;\n      this.counters.get(name, next);\n      var message = name + ': ' + next;\n      this.browser.emit('console', 'log', message);\n    }\n  }, {\n    key: 'debug',\n    value: function debug() {\n      this.browser.emit('console', 'debug', format.apply(undefined, arguments));\n    }\n  }, {\n    key: 'error',\n    value: function error() {\n      this.browser.emit('console', 'error', format.apply(undefined, arguments));\n    }\n  }, {\n    key: 'group',\n    value: function group() {}\n  }, {\n    key: 'groupCollapsed',\n    value: function groupCollapsed() {}\n  }, {\n    key: 'groupEnd',\n    value: function groupEnd() {}\n  }, {\n    key: 'dir',\n    value: function dir(object) {\n      this.browser.emit('console', 'log', inspect(object));\n    }\n  }, {\n    key: 'info',\n    value: function info() {\n      this.browser.emit('console', 'log', format.apply(undefined, arguments));\n    }\n  }, {\n    key: 'log',\n    value: function log() {\n      this.browser.emit('console', 'log', format.apply(undefined, arguments));\n    }\n  }, {\n    key: 'time',\n    value: function time(name) {\n      this.timers.set(name, Date.now());\n    }\n  }, {\n    key: 'timeEnd',\n    value: function timeEnd(name) {\n      var start = this.timers.set(name);\n      this.timers['delete'](name);\n      var message = name + ': ' + (Date.now() - start) + 'ms';\n      this.browser.emit('console', 'log', message);\n    }\n  }, {\n    key: 'trace',\n    value: function trace() {\n      var error = new Error();\n      var stack = error.stack.split('\\n');\n      stack[0] = 'console.trace()';\n      var message = stack.join('\\n');\n      this.browser.emit('console', 'trace', message);\n    }\n  }, {\n    key: 'warn',\n    value: function warn() {\n      this.browser.emit('console', 'log', format.apply(undefined, arguments));\n    }\n  }]);\n\n  return Console;\n})();\n//# sourceMappingURL=console.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/cookies.js":"// See [RFC 2109](http://tools.ietf.org/html/rfc2109.html) and\n// [document.cookie](http://dev/loper.mozilla.org/en/document.cookie)\n'use strict';\n\nvar _get = require('babel-runtime/helpers/get')['default'];\n\nvar _inherits = require('babel-runtime/helpers/inherits')['default'];\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar DOM = require('./dom');\n\nvar _require = require('util');\n\nvar isArray = _require.isArray;\n\nvar Tough = require('tough-cookie');\nvar Cookie = Tough.Cookie;\n\n// Lists all available cookies.\nmodule.exports = (function (_Array) {\n  _inherits(Cookies, _Array);\n\n  function Cookies() {\n    _classCallCheck(this, Cookies);\n\n    _get(Object.getPrototypeOf(Cookies.prototype), 'constructor', this).call(this);\n  }\n\n  // Used to dump state to console (debugging)\n\n  _createClass(Cookies, [{\n    key: 'dump',\n    value: function dump() {\n      var output = arguments.length <= 0 || arguments[0] === undefined ? process.stdout : arguments[0];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(this.sort(Tough.cookieCompare)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var cookie = _step.value;\n\n          output.write(cookie + '\\n');\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    // Serializes all selected cookies into a single string.  Used to generate a cookies header.\n    //\n    // domain - Request hostname\n    // path   - Request pathname\n  }, {\n    key: 'serialize',\n    value: function serialize(domain, path) {\n      return this.select({ domain: domain, path: path }).map(function (cookie) {\n        return cookie.cookieString();\n      }).join('; ');\n    }\n\n    // Returns all cookies that match the identifier (name, domain and path).\n    // This is used for retrieving cookies.\n  }, {\n    key: 'select',\n    value: function select(identifier) {\n      var cookies = this.filter(function (cookie) {\n        return cookie.TTL() > 0;\n      }); // eslint-disable-line new-cap\n      if (identifier.name) cookies = cookies.filter(function (cookie) {\n        return cookie.key === identifier.name;\n      });\n      if (identifier.path) cookies = cookies.filter(function (cookie) {\n        return Tough.pathMatch(identifier.path, cookie.path);\n      });\n      if (identifier.domain) cookies = cookies.filter(function (cookie) {\n        return Tough.domainMatch(identifier.domain, cookie.domain);\n      });\n      return cookies.sort(function (a, b) {\n        return b.domain.length - a.domain.length;\n      }).sort(Tough.cookieCompare);\n    }\n\n    // Adds a new cookie, updates existing cookie (same name, domain and path), or\n    // deletes a cookie (if expires in the past).\n  }, {\n    key: 'set',\n    value: function set(params) {\n      var _this = this;\n\n      var cookie = new Cookie({\n        key: params.name,\n        value: params.value,\n        domain: params.domain || 'localhost',\n        path: params.path || '/'\n      });\n      if (params.expires) cookie.setExpires(params.expires);else if (params.hasOwnProperty('max-age')) cookie.setMaxAge(params['max-age']);\n      cookie.secure = !!params.secure;\n      cookie.httpOnly = !!params.httpOnly;\n\n      // Delete cookie before setting it, so we only store one cookie (per\n      // domain/path/name)\n      this.filter(function (c) {\n        return c.domain === cookie.domain;\n      }).filter(function (c) {\n        return c.path === cookie.path;\n      }).filter(function (c) {\n        return c.key === cookie.key;\n      }).forEach(function (c) {\n        return _this['delete'](c);\n      });\n      if (cookie.TTL() > 0) // eslint-disable-line new-cap\n        this.push(cookie);\n    }\n\n    // Delete the specified cookie.\n  }, {\n    key: 'delete',\n    value: function _delete(cookie) {\n      var index = this.indexOf(cookie);\n      if (~index) this.splice(index, 1);\n    }\n\n    // Deletes all cookies.\n  }, {\n    key: 'deleteAll',\n    value: function deleteAll() {\n      this.length = 0;\n    }\n\n    // Update cookies with HTTP response\n    //\n    // httpHeader - Value of HTTP Set-Cookie header (string/array)\n    // domain     - Set from hostname\n    // path       - Set from pathname\n  }, {\n    key: 'update',\n    value: function update(httpHeader, domain, path) {\n      var _this2 = this;\n\n      // One Set-Cookie is a string, multiple is an array\n      var headers = isArray(httpHeader) ? httpHeader : [httpHeader];\n      headers.map(function (cookie) {\n        return Cookie.parse(cookie);\n      }).filter(function (cookie) {\n        return cookie;\n      }).forEach(function (cookie) {\n        cookie.domain = cookie.domain || domain;\n        cookie.path = cookie.path || Tough.defaultPath(path);\n\n        // Delete cookie before setting it, so we only store one cookie (per\n        // domain/path/name)\n        _this2.filter(function (c) {\n          return c.domain === cookie.domain;\n        }).filter(function (c) {\n          return c.path === cookie.path;\n        }).filter(function (c) {\n          return c.key === cookie.key;\n        }).forEach(function (c) {\n          return _this2['delete'](c);\n        });\n        if (cookie.TTL() > 0) // eslint-disable-line new-cap\n          _this2.push(cookie);\n      });\n    }\n  }]);\n\n  return Cookies;\n})(Array);\n\n// Returns name=value pairs\nDOM.HTMLDocument.prototype.__defineGetter__('cookie', function () {\n  var cookies = this.defaultView.browser.cookies;\n\n  return cookies.select({ domain: this.location.hostname, path: this.location.pathname }).filter(function (cookie) {\n    return !cookie.httpOnly;\n  }).map(function (cookie) {\n    return cookie.key + '=' + cookie.value;\n  }).join('; ');\n});\n\n// Accepts serialized form (same as Set-Cookie header) and updates cookie from\n// new values.\nDOM.HTMLDocument.prototype.__defineSetter__('cookie', function (cookie) {\n  var cookies = this.defaultView.browser.cookies;\n\n  cookies.update(cookie.toString(), this.location.hostname, this.location.pathname);\n});\n//# sourceMappingURL=cookies.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/eventloop.js":"// The event loop.\n//\n// Each browser has an event loop, which processes asynchronous events like\n// loading pages and resources, XHR, timeouts and intervals, etc. These are\n// procesed in order.\n//\n// The purpose of the event loop is two fold:\n// - To get events processed in the right order for the active window (and only\n//   the active window)\n// - And to allow the code to wait until all events have been processed\n//   (browser.wait, .visit, .pressButton, etc)\n//\n// The event loop has one interesting method: `wait`.\n//\n// Each window maintains its own event queue. Its interesting methods are\n// `enqueue`, `http`, `dispatch` and the timeout/interval methods.\n\n'use strict';\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _get = require('babel-runtime/helpers/get')['default'];\n\nvar _inherits = require('babel-runtime/helpers/inherits')['default'];\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar _Array$from = require('babel-runtime/core-js/array/from')['default'];\n\nvar assert = require('assert');\n\nvar _require = require('events');\n\nvar EventEmitter = _require.EventEmitter;\n\n// Wrapper for a timeout (setTimeout)\n\nvar Timeout = (function () {\n\n  // eventQueue - Reference to the event queue\n  // fn         - When timer fires, evaluate this function\n  // delay      - How long to wait\n  // remove     - Call this to discard timer\n  //\n  // Instance variables add:\n  // handle  - Node.js timeout handle\n  // next    - When is this timer firing next\n\n  function Timeout(eventQueue, fn, delay, remove) {\n    _classCallCheck(this, Timeout);\n\n    this.eventQueue = eventQueue;\n    this.fn = fn;\n    this.delay = Math.max(delay || 0, 0);\n    this.remove = remove;\n\n    this.handle = global.setTimeout(this.fire.bind(this), this.delay);\n    this.next = Date.now() + this.delay;\n  }\n\n  // Wrapper for an interval (setInterval)\n\n  _createClass(Timeout, [{\n    key: 'fire',\n    value: function fire() {\n      var _this = this;\n\n      // In response to Node firing setTimeout, but only allowed to process this\n      // event during a wait()\n      this.eventQueue.enqueue(function () {\n        var eventLoop = _this.eventQueue.eventLoop;\n\n        eventLoop.emit('setTimeout', _this.fn, _this.delay);\n        try {\n          _this.eventQueue.window._evaluate(_this.fn);\n        } catch (error) {\n          eventLoop.emit('error', error);\n        }\n      });\n      this.remove();\n    }\n\n    // clearTimeout\n  }, {\n    key: 'stop',\n    value: function stop() {\n      global.clearTimeout(this.handle);\n      this.remove();\n    }\n  }]);\n\n  return Timeout;\n})();\n\nvar Interval = (function () {\n\n  // eventQueue - Reference to the event queue\n  // fn        - When timer fires, evaluate this function\n  // interval  - Interval between firing\n  // remove    - Call this to discard timer\n  //\n  // Instance variables add:\n  // handle  - Node.js interval handle\n  // next    - When is this timer firing next\n\n  function Interval(eventQueue, fn, interval, remove) {\n    _classCallCheck(this, Interval);\n\n    this.eventQueue = eventQueue;\n    this.fn = fn;\n    this.interval = Math.max(interval || 0, 0);\n    this.remove = remove;\n    this.fireInProgress = false;\n    this.handle = global.setInterval(this.fire.bind(this), this.interval);\n    this.next = Date.now() + this.interval;\n  }\n\n  // Each window has an event queue that holds all pending events.  Various\n  // browser features push new functions into the queue (e.g. process XHR\n  // response, setTimeout fires).  The event loop is responsible to pop these\n  // events from the queue and run them, but only during browser.wait().\n  //\n  // In addition, the event queue keeps track of all outstanding timers\n  // (setTimeout/setInterval) so it can return consecutive handles and clean them\n  // up during window.destroy().\n  //\n  // In addition, we keep track of when the browser is expecting an event to\n  // arrive in the queue (e.g. sent XHR request, expecting an event to process the\n  // response soon enough).  The event loop uses that to determine if it's worth\n  // waiting.\n\n  _createClass(Interval, [{\n    key: 'fire',\n    value: function fire() {\n      var _this2 = this;\n\n      // In response to Node firing setInterval, but only allowed to process this\n      // event during a wait()\n      this.next = Date.now() + this.interval;\n\n      // setInterval events not allowed to overlap, don't queue two at once\n      if (this.fireInProgress) return;\n      this.fireInProgress = true;\n      this.eventQueue.enqueue(function () {\n        _this2.fireInProgress = false;\n\n        var eventLoop = _this2.eventQueue.eventLoop;\n\n        eventLoop.emit('setInterval', _this2.fn, _this2.interval);\n        try {\n          _this2.eventQueue.window._evaluate(_this2.fn);\n        } catch (error) {\n          eventLoop.emit('error', error);\n        }\n      });\n    }\n\n    // clearTimeout\n  }, {\n    key: 'stop',\n    value: function stop() {\n      global.clearInterval(this.handle);\n      this.remove();\n    }\n  }]);\n\n  return Interval;\n})();\n\nvar EventQueue = (function () {\n\n  // Instance variables:\n  // browser          - Reference to the browser\n  // eventLoop        - Reference to the browser's event loop\n  // queue            - FIFO queue of functions to call\n  // expecting        - These are holding back the event loop\n  // timers           - Sparse array of timers (index is the timer handle)\n  // eventSources     - Additional sources for events (SSE, WS, etc)\n  // nextTimerHandle  - Value of next timer handler\n\n  function EventQueue(window) {\n    _classCallCheck(this, EventQueue);\n\n    this.window = window;\n    this.browser = window.browser;\n    this.eventLoop = this.browser._eventLoop;\n    this.queue = [];\n    this.expecting = 0;\n    this.timers = [];\n    this.eventSources = [];\n    this.nextTimerHandle = 1;\n  }\n\n  // The browser event loop.\n  //\n  // Each browser has one event loop that processes events from the queues of the\n  // currently active window and its frames (child windows).\n  //\n  // The wait method is responsible to process all pending events.  It goes idle\n  // once:\n  // - There are no more events waiting in the queue (of the active window)\n  // - There are no more timers waiting to fire (next -> Infinity)\n  // - No future events are expected to arrive (e.g. in-progress XHR requests)\n  //\n  // The wait method will complete before the loop goes idle, if:\n  // - Past the specified timeout\n  // - The next scheduled timer is past the specified timeout\n  // - The completio function evaluated to true\n  //\n  // While processing, the event loop emits the following events (on the browser\n  // object):\n  // tick(next) - Emitted after executing a single event; the argument is the\n  //              expected duration until the next event (in ms)\n  // idle       - Emitted when there are no more events (queued or expected)\n  // error(err) - Emitted after an error\n\n  // Cleanup when we dispose of the window\n\n  _createClass(EventQueue, [{\n    key: 'destroy',\n    value: function destroy() {\n      if (!this.queue) return;\n      this.queue = null;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(this.timers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var timer = _step.value;\n\n          if (timer) timer.stop();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.timers = null;\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = _getIterator(this.eventSources), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var eventSource = _step2.value;\n\n          //if (eventSource)\n          eventSource.close();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n            _iterator2['return']();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.eventSources = null;\n    }\n\n    // -- Events --\n\n    // Any events expected in the future?\n  }, {\n    key: 'enqueue',\n\n    // Add a function to the event queue, to be executed in order.\n    value: function enqueue(fn) {\n      assert(this.queue, 'This browser has been destroyed');\n      assert(typeof fn === 'function', 'eventLoop.enqueue called without a function');\n\n      if (fn) {\n        this.queue.push(fn);\n        this.eventLoop.run();\n      }\n    }\n\n    // Wait for completion.  Returns a completion function, event loop will remain\n    // active until the completion function is called;\n  }, {\n    key: 'waitForCompletion',\n    value: function waitForCompletion() {\n      var _this3 = this;\n\n      ++this.expecting;\n      return function () {\n        --_this3.expecting;\n        setImmediate(function () {\n          _this3.eventLoop.run();\n        });\n      };\n    }\n\n    // Event loop uses this to grab event from top of the queue.\n  }, {\n    key: 'dequeue',\n    value: function dequeue() {\n      assert(this.queue, 'This browser has been destroyed');\n\n      var fn = this.queue.shift();\n      if (fn) return fn;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = _getIterator(_Array$from(this.window.frames)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var frame = _step3.value;\n\n          var childFn = frame._eventQueue.dequeue();\n          if (childFn) return childFn;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3['return']) {\n            _iterator3['return']();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    // Makes an HTTP request.\n    //\n    // request  - Request object\n    // callback - Called with Response object to process the response\n    //\n    // Because the callback is added to the queue, we can't use promises\n  }, {\n    key: 'http',\n    value: function http(request, callback) {\n      var _this4 = this;\n\n      assert(this.queue, 'This browser has been destroyed');\n\n      var done = this.waitForCompletion();\n      this.window.fetch(request).then(function (response) {\n        // We can't cancel pending requests, but we can ignore the response if\n        // window already closed\n        if (_this4.queue)\n          // This will get completion function to execute, e.g. to check a page\n          // before meta tag refresh\n          _this4.enqueue(function () {\n            callback(null, response);\n          });\n      })['catch'](function (error) {\n        if (_this4.queue) callback(error);\n      }).then(done);\n    }\n\n    // Fire an error event.  Used by JSDOM patches.\n  }, {\n    key: 'onerror',\n    value: function onerror(error) {\n      assert(this.queue, 'This browser has been destroyed');\n\n      this.eventLoop.emit('error', error);\n\n      var event = this.window.document.createEvent('Event');\n      event.initEvent('error', false, false);\n      event.message = error.message;\n      event.error = error;\n      this.window.dispatchEvent(event);\n    }\n\n    // -- EventSource --\n\n  }, {\n    key: 'addEventSource',\n    value: function addEventSource(eventSource) {\n      var _this5 = this;\n\n      assert(this.queue, 'This browser has been destroyed');\n\n      this.eventSources.push(eventSource);\n\n      var emit = eventSource.emit;\n      eventSource.emit = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this5.eventLoop.emit('serverEvent');\n        _this5.enqueue(function () {\n          emit.apply(eventSource, args);\n        });\n      };\n    }\n\n    // -- Timers --\n\n    // Window.setTimeout\n  }, {\n    key: 'setTimeout',\n    value: function setTimeout(fn) {\n      var _this6 = this;\n\n      var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      assert(this.queue, 'This browser has been destroyed');\n      if (!fn) return null;\n\n      var handle = this.nextTimerHandle;\n      ++this.nextTimerHandle;\n      this.timers[handle] = new Timeout(this, fn, delay, function () {\n        delete _this6.timers[handle];\n      });\n      return handle;\n    }\n\n    // Window.clearTimeout\n  }, {\n    key: 'clearTimeout',\n    value: function clearTimeout(handle) {\n      assert(this.queue, 'This browser has been destroyed');\n\n      var timer = this.timers[handle];\n      if (timer) timer.stop();\n    }\n\n    // Window.setInterval\n  }, {\n    key: 'setInterval',\n    value: function setInterval(fn) {\n      var _this7 = this;\n\n      var interval = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      assert(this.queue, 'This browser has been destroyed');\n      if (!fn) return null;\n\n      var handle = this.nextTimerHandle;\n      ++this.nextTimerHandle;\n      this.timers[handle] = new Interval(this, fn, interval, function () {\n        delete _this7.timers[handle];\n      });\n      return handle;\n    }\n\n    // Window.clearInterval\n  }, {\n    key: 'clearInterval',\n    value: function clearInterval(handle) {\n      assert(this.queue, 'This browser has been destroyed');\n\n      var timer = this.timers[handle];\n      if (timer) timer.stop();\n    }\n\n    // Returns the timestamp of the next timer event\n  }, {\n    key: 'expected',\n    get: function get() {\n      return !!(this.expecting || _Array$from(this.window.frames).filter(function (frame) {\n        return frame._eventQueue.expected;\n      }).length);\n    }\n  }, {\n    key: 'next',\n    get: function get() {\n      var timers = this.timers.map(function (timer) {\n        return timer.next;\n      });\n      var frames = _Array$from(this.window.frames).map(function (frame) {\n        return frame._eventQueue.next;\n      });\n      return timers.concat(frames).sort()[0] || Infinity;\n    }\n  }]);\n\n  return EventQueue;\n})();\n\nmodule.exports = (function (_EventEmitter) {\n  _inherits(EventLoop, _EventEmitter);\n\n  // Instance variables are:\n  // active    - Currently active window\n  // browser   - Reference to the browser\n  // running   - True when inside a run loop\n  // waiting   - Counts in-progess calls to wait (waiters?)\n\n  function EventLoop(browser) {\n    _classCallCheck(this, EventLoop);\n\n    _get(Object.getPrototypeOf(EventLoop.prototype), 'constructor', this).call(this);\n    this.browser = browser;\n    this.active = null;\n    this.running = false;\n    this.waiting = 0;\n  }\n\n  // -- The wait function --\n\n  // Wait until one of these happen:\n  // 1. We run out of events to process; callback is called with null and false\n  // 2. The completion function evaluates to true; callback is called with null\n  //    and false\n  // 3. The time duration elapsed; callback is called with null and true\n  // 2. An error occurs; callback is called with an error\n  //\n  // Duration is specifies in milliseconds or string form (e.g. \"15s\").\n  //\n  // Completion function is called with the currently active window (may change\n  // during page navigation or form submission) and how long until the next\n  // event, and returns true to stop waiting, any other value to continue\n  // processing events.\n  //\n  //\n  // waitDuration       - How long to wait (ms)\n  // completionFunction - Returns true for early completion\n\n  _createClass(EventLoop, [{\n    key: 'wait',\n    value: function wait(waitDuration, completionFunction, callback) {\n      assert(waitDuration, 'Wait duration required, cannot be 0');\n      var eventLoop = this;\n\n      ++eventLoop.waiting;\n      // Someone (us) just started paying attention, start processing events\n      if (eventLoop.waiting === 1) setImmediate(function () {\n        return eventLoop.run();\n      });\n\n      // The timer fires when we waited long enough, we need timeoutOn to tell if\n      // the next event is past the wait duration and there's no point in waiting\n      // further\n      var timer = global.setTimeout(timeout, waitDuration); // eslint-disable-line no-use-before-define\n      var timeoutOn = Date.now() + waitDuration;\n\n      // Fired after every event, decide if we want to stop waiting\n      function ontick(next) {\n        // No point in waiting that long\n        if (next >= timeoutOn) {\n          timeout();\n          return;\n        }\n\n        var activeWindow = eventLoop.active;\n        if (completionFunction && activeWindow.document.documentElement) try {\n          var waitFor = Math.max(next - Date.now(), 0);\n          // Event processed, are we ready to complete?\n          var completed = completionFunction(activeWindow, waitFor);\n          if (completed) done();\n        } catch (error) {\n          done(error);\n        }\n      }\n\n      // The wait is over ...\n      function done(error) {\n        global.clearTimeout(timer);\n        eventLoop.removeListener('tick', ontick);\n        eventLoop.removeListener('idle', done);\n        eventLoop.browser.removeListener('error', done);\n\n        --eventLoop.waiting;\n        try {\n          callback(error);\n        } catch (error) {\n          // If callback makes an assertion that fails, we end here.\n          // If we throw error synchronously, it gets swallowed.\n          setImmediate(function () {\n            throw error;\n          });\n        }\n      }\n\n      // We gave up, could be result of slow response ...\n      function timeout() {\n        if (eventLoop.expected) done(new Error('Timeout: did not get to load all resources on this page'));else done();\n      }\n\n      eventLoop.on('tick', ontick);\n\n      // Fired when there are no more events to process\n      eventLoop.once('idle', done);\n\n      // Stop on first error reported (document load, script, etc)\n      // Event loop errors also propagated to the browser\n      eventLoop.browser.once('error', done);\n    }\n  }, {\n    key: 'dump',\n    value: function dump() {\n      var output = arguments.length <= 0 || arguments[0] === undefined ? process.stdout : arguments[0];\n\n      if (this.running) output.write('Event loop: running\\n');else if (this.expected) output.write('Event loop: waiting for ' + this.expected + ' events\\n');else if (this.waiting) output.write('Event loop: waiting\\n');else output.write('Event loop: idle\\n');\n    }\n\n    // -- Event queue management --\n\n    // Creates and returns a new event queue (see EventQueue).\n  }, {\n    key: 'createEventQueue',\n    value: function createEventQueue(window) {\n      return new EventQueue(window);\n    }\n\n    // Set the active window. Suspends processing events from any other window, and\n    // switches to processing events from this window's queue.\n  }, {\n    key: 'setActiveWindow',\n    value: function setActiveWindow(window) {\n      if (window === this.active) return;\n      this.active = window;\n      this.run(); // new window, new events?\n    }\n\n    // Are there any expected events for the active window?\n  }, {\n    key: 'run',\n\n    // -- Event processing --\n\n    // Grabs next event from the queue, processes it and notifies all listeners.\n    // Keeps processing until the queue is empty or all listeners are gone. You\n    // only need to bootstrap this when you suspect it's not recursing.\n    value: function run() {\n      var _this8 = this;\n\n      // A lot of code calls run() without checking first, so not uncommon to have\n      // concurrent executions of this function\n      if (this.running) return;\n      // Is there anybody out there?\n      if (this.waiting === 0) return;\n\n      // Give other (Node) events a chance to process\n      this.running = true;\n      setImmediate(function () {\n        _this8.running = false;\n        try {\n\n          // Are there any open windows?\n          if (!_this8.active) {\n            _this8.emit('idle');\n            return;\n          }\n          // Don't run event outside browser.wait()\n          if (_this8.waiting === 0) return;\n\n          var jsdomQueue = _this8.active.document._queue;\n          var _event = _this8.active._eventQueue.dequeue();\n          if (_event) {\n            // Process queued function, tick, and on to next event\n            _event();\n            _this8.emit('tick', 0);\n            _this8.run();\n          } else if (_this8.expected > 0)\n            // We're waiting for some events to come along, don't know when,\n            // but they'll call run for us\n            _this8.emit('tick', 0);else if (jsdomQueue.tail) {\n            jsdomQueue.resume();\n            _this8.run();\n          } else {\n            // All that's left are timers, and not even that if next == Infinity\n            var next = _this8.active._eventQueue.next;\n            if (isFinite(next)) _this8.emit('tick', next);else _this8.emit('idle');\n          }\n        } catch (error) {\n          _this8.emit('error', error);\n        }\n      });\n    }\n  }, {\n    key: 'expected',\n    get: function get() {\n      return this.active && this.active._eventQueue.expected;\n    }\n  }]);\n\n  return EventLoop;\n})(EventEmitter);\n//# sourceMappingURL=eventloop.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/pipeline.js":"'use strict';\n\nvar _get = require('babel-runtime/helpers/get')['default'];\n\nvar _inherits = require('babel-runtime/helpers/inherits')['default'];\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar _Promise = require('babel-runtime/core-js/promise')['default'];\n\nvar _ = require('lodash');\nvar assert = require('assert');\nvar Bluebird = require('bluebird');\nvar Fetch = require('./fetch');\nvar File = require('fs');\n\nvar _require = require('./fetch');\n\nvar Headers = _require.Headers;\n\nvar _require2 = require('util');\n\nvar isArray = _require2.isArray;\n\nvar Path = require('path');\nvar Request = require('request');\nvar resourceLoader = require('jsdom/lib/jsdom/browser/resource-loader');\nvar URL = require('url');\nvar Utils = require('jsdom/lib/jsdom/utils');\n\n// Pipeline is sequence of request/response handlers that are used to prepare a\n// request, make the request, and process the response.\n\nvar Pipeline = (function (_Array) {\n  _inherits(Pipeline, _Array);\n\n  function Pipeline(browser) {\n    _classCallCheck(this, Pipeline);\n\n    _get(Object.getPrototypeOf(Pipeline.prototype), 'constructor', this).call(this);\n    this._browser = browser;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _getIterator(Pipeline._default), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var handler = _step.value;\n\n        this.push(handler);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator['return']) {\n          _iterator['return']();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  // The default pipeline.  All new pipelines are instantiated with this set of\n  // handlers.\n\n  _createClass(Pipeline, [{\n    key: '_fetch',\n    value: function _fetch(input, init) {\n      var request = new Fetch.Request(input, init);\n      var browser = this._browser;\n      browser.emit('request', request);\n\n      return this._runPipeline(request).then(function (response) {\n        response.time = Date.now();\n        response.request = request;\n        browser.emit('response', request, response);\n        return response;\n      })['catch'](function (error) {\n        browser._debug('Resource error', error.stack);\n        throw new TypeError(error.message);\n      });\n    }\n  }, {\n    key: '_runPipeline',\n    value: function _runPipeline(request) {\n      var _this = this;\n\n      return this._getOriginalResponse(request).then(function (response) {\n        return _this._prepareResponse(request, response);\n      });\n    }\n  }, {\n    key: '_getOriginalResponse',\n    value: function _getOriginalResponse(request) {\n      var browser = this._browser;\n      var requestHandlers = this.filter(function (fn) {\n        return fn.length === 2;\n      }).concat(Pipeline.makeHTTPRequest);\n\n      return Bluebird.reduce(requestHandlers, function (lastResponse, requestHandler) {\n        return lastResponse || requestHandler(browser, request);\n      }, null).then(function (response) {\n        assert(response && response.hasOwnProperty('statusText'), 'Request handler must return a response');\n        return response;\n      });\n    }\n  }, {\n    key: '_prepareResponse',\n    value: function _prepareResponse(request, originalResponse) {\n      var browser = this._browser;\n      var responseHandlers = this.filter(function (fn) {\n        return fn.length === 3;\n      });\n\n      return Bluebird.reduce(responseHandlers, function (lastResponse, responseHandler) {\n        return responseHandler(browser, request, lastResponse);\n      }, originalResponse).then(function (response) {\n        assert(response && response.hasOwnProperty('statusText'), 'Response handler must return a response');\n        return response;\n      });\n    }\n\n    // -- Handlers --\n\n    // Add a request or response handler.  This handler will only be used by this\n    // pipeline instance (browser).\n  }, {\n    key: 'addHandler',\n    value: function addHandler(handler) {\n      assert(handler.call, 'Handler must be a function');\n      assert(handler.length === 2 || handler.length === 3, 'Handler function takes 2 (request handler) or 3 (reponse handler) arguments');\n      this.push(handler);\n    }\n\n    // Remove a request or response handler.\n  }, {\n    key: 'removeHandler',\n    value: function removeHandler(handler) {\n      assert(handler.call, 'Handler must be a function');\n      var index = this.indexOf(handler);\n      if (index > -1) {\n        this.splice(index, 1);\n      }\n    }\n\n    // Add a request or response handler.  This handler will be used by any new\n    // pipeline instance (browser).\n  }], [{\n    key: 'addHandler',\n    value: function addHandler(handler) {\n      assert(handler.call, 'Handler must be a function');\n      assert(handler.length === 2 || handler.length === 3, 'Handler function takes 2 (request handler) or 3 (response handler) arguments');\n      this._default.push(handler);\n    }\n\n    // Remove a request or response handler.\n  }, {\n    key: 'removeHandler',\n    value: function removeHandler(handler) {\n      assert(handler.call, 'Handler must be a function');\n      var index = this._default.indexOf(handler);\n      if (index > -1) {\n        this._default.splice(index, 1);\n      }\n    }\n\n    // -- Prepare request --\n\n    // This handler normalizes the request URL.\n    //\n    // It turns relative URLs into absolute URLs based on the current document URL\n    // or base element, or if no document open, based on browser.site property.\n  }, {\n    key: 'normalizeURL',\n    value: function normalizeURL(browser, request) {\n      if (browser.document)\n        // Resolve URL relative to document URL/base, or for new browser, using\n        // Browser.site\n        request.url = resourceLoader.resolveResourceUrl(browser.document, request.url);else request.url = Utils.resolveHref(browser.site || 'http://localhost', request.url);\n    }\n\n    // This handler mergers request headers.\n    //\n    // It combines headers provided in the request with custom headers defined by\n    // the browser (user agent, authentication, etc).\n    //\n    // It also normalizes all headers by down-casing the header names.\n  }, {\n    key: 'mergeHeaders',\n    value: function mergeHeaders(browser, request) {\n      if (browser.headers) _.each(browser.headers, function (value, name) {\n        request.headers.append(name, browser.headers[name]);\n      });\n      if (!request.headers.has('User-Agent')) request.headers.set('User-Agent', browser.userAgent);\n\n      // Always pass Host: from request URL\n\n      var _URL$parse = URL.parse(request.url);\n\n      var host = _URL$parse.host;\n\n      request.headers.set('Host', host);\n\n      // HTTP Basic authentication\n      var authenticate = { host: host, username: null, password: null };\n      browser.emit('authenticate', authenticate);\n      var username = authenticate.username;\n      var password = authenticate.password;\n\n      if (username && password) {\n        browser.log('Authenticating as ' + username + ':' + password);\n        var base64 = new Buffer(username + ':' + password).toString('base64');\n        request.headers.set('authorization', 'Basic ' + base64);\n      }\n    }\n\n    // -- Retrieve actual resource --\n\n    // Used to perform HTTP request (also supports file: resources).  This is always\n    // the last request handler.\n  }, {\n    key: 'makeHTTPRequest',\n    value: function makeHTTPRequest(browser, request) {\n      var url = request.url;\n\n      var _URL$parse2 = URL.parse(url);\n\n      var protocol = _URL$parse2.protocol;\n      var hostname = _URL$parse2.hostname;\n      var pathname = _URL$parse2.pathname;\n\n      if (protocol === 'file:') {\n\n        // If the request is for a file:// descriptor, just open directly from the\n        // file system rather than getting node's http (which handles file://\n        // poorly) involved.\n        if (request.method !== 'GET') return new Fetch.Response('', { url: url, status: 405 });\n\n        var filename = Path.normalize(decodeURI(pathname));\n        var exists = File.existsSync(filename);\n        if (exists) {\n          var stream = File.createReadStream(filename);\n          return new Fetch.Response(stream, { url: url, status: 200 });\n        } else return new Fetch.Response('', { url: url, status: 404 });\n      }\n\n      // We're going to use cookies later when receiving response.\n      var cookies = browser.cookies;\n\n      var cookieHeader = cookies.serialize(hostname, pathname);\n      if (cookieHeader) request.headers.append('Cookie', cookieHeader);\n\n      var consumeBody = /^POST|PUT/.test(request.method) && request._consume() || _Promise.resolve(null);\n      return consumeBody.then(function (body) {\n\n        var httpRequest = new Request({\n          method: request.method,\n          uri: request.url,\n          headers: request.headers.toObject(),\n          proxy: browser.proxy,\n          body: body,\n          jar: false,\n          followRedirect: false,\n          strictSSL: browser.strictSSL,\n          localAddress: browser.localAddress || 0\n        });\n\n        return new _Promise(function (resolve, reject) {\n          httpRequest.on('response', function (response) {\n            // Request returns an object where property name is header name,\n            // property value is either header value, or an array if header sent\n            // multiple times (e.g. `Set-Cookie`).\n            var arrayOfHeaders = _.reduce(response.headers, function (headers, value, name) {\n              if (isArray(value)) {\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                  for (var _iterator2 = _getIterator(value), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var item = _step2.value;\n\n                    headers.push([name, item]);\n                  }\n                } catch (err) {\n                  _didIteratorError2 = true;\n                  _iteratorError2 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n                      _iterator2['return']();\n                    }\n                  } finally {\n                    if (_didIteratorError2) {\n                      throw _iteratorError2;\n                    }\n                  }\n                }\n              } else headers.push([name, value]);\n              return headers;\n            }, []);\n\n            resolve(new Fetch.Response(response, {\n              url: request.url,\n              status: response.statusCode,\n              headers: new Headers(arrayOfHeaders)\n            }));\n          }).on('error', reject);\n        });\n      });\n    }\n\n    // -- Handle response --\n\n  }, {\n    key: 'handleHeaders',\n    value: function handleHeaders(browser, request, response) {\n      response.headers = new Headers(response.headers);\n      return response;\n    }\n  }, {\n    key: 'handleCookies',\n    value: function handleCookies(browser, request, response) {\n      // Set cookies from response: call update() with array of headers\n\n      var _URL$parse3 = URL.parse(request.url);\n\n      var hostname = _URL$parse3.hostname;\n      var pathname = _URL$parse3.pathname;\n\n      var newCookies = response.headers.getAll('Set-Cookie');\n      browser.cookies.update(newCookies, hostname, pathname);\n      return response;\n    }\n  }, {\n    key: 'handleRedirect',\n    value: function handleRedirect(browser, request, response) {\n      var status = response.status;\n\n      if (status === 301 || status === 302 || status === 303 || status === 307 || status === 308) {\n        if (request.redirect === 'error') return Fetch.Response.error();\n\n        var _location = response.headers.get('Location');\n        if (_location === null) return response;\n\n        if (request._redirectCount >= 20) return Fetch.Response.error();\n\n        browser.emit('redirect', request, response, _location);\n        ++request._redirectCount;\n        if (status !== 307) {\n          request.method = 'GET';\n          request.headers['delete']('Content-Type');\n          request.headers['delete']('Content-Length');\n          request.headers['delete']('Content-Transfer-Encoding');\n        }\n\n        // This request is referer for next\n        request.headers.set('Referer', request.url);\n        request.url = Utils.resolveHref(request.url, _location);\n        return browser.pipeline._runPipeline(request);\n      } else return response;\n    }\n  }]);\n\n  return Pipeline;\n})(Array);\n\nPipeline._default = [Pipeline.normalizeURL, Pipeline.mergeHeaders, Pipeline.handleHeaders, Pipeline.handleCookies, Pipeline.handleRedirect];\n\nmodule.exports = Pipeline;\n//# sourceMappingURL=pipeline.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/reroute.js":"// Domain routing and port forwarding\n//\n// Used for mapping hosts and domains to localhost, so you can open TCP\n// connections with friendly hostnames to test against the local server.\n//\n// Can also map any source port to any destination port, so you can use port 80\n// to access localhost server running on unprivileged port.\n\n'use strict';\n\nvar _Map = require('babel-runtime/core-js/map')['default'];\n\nvar _Object$assign = require('babel-runtime/core-js/object/assign')['default'];\n\nvar assert = require('assert');\nvar Net = require('net');\n\n// Routing table.\n//\n// key   - Source host name or wildcard (e.g. \"example.com\", \"*.example.com\")\n// value - Object that maps source port to target port\nvar routing = new _Map();\n\n// Flip this from enableRerouting() so we only inject our code into\n// Socket.connect once.\nvar enabled = false;\n\n// If there's a route for host/port, returns destination port number.\n//\n// Called recursively to handle wildcards.  Starting with the host\n// www.example.com, it will attempt to match routes from most to least specific:\n//\n//   www.example.com\n// *.www.example.com\n//     *.example.com\n//             *.com\nfunction findTargetPort(_x, _x2) {\n  var _again = true;\n\n  _function: while (_again) {\n    var hostname = _x,\n        port = _x2;\n    _again = false;\n\n    var route = routing.get(hostname);\n    if (route) return route[port];\n\n    // This will first expand www.hostname.com to *.www.hostname.com,\n    // then contract it to *.hostname.com, *.com and finally *.\n    var wildcard = hostname.replace(/^(\\*\\.[^.]+(\\.|$))?/, '*.');\n    if (wildcard !== '*.') {\n      _x = wildcard;\n      _x2 = port;\n      _again = true;\n      route = wildcard = undefined;\n      continue _function;\n    }\n  }\n}\n\n// Called once to hack Socket.connect\nfunction enableRerouting() {\n  if (enabled) return;\n  enabled = true;\n\n  var connect = Net.Socket.prototype.connect;\n  Net.Socket.prototype.connect = function (options, callback) {\n    if (typeof options === 'object') {\n      var port = findTargetPort(options.host, options.port);\n      if (port) {\n        options = _Object$assign({}, options, { host: 'localhost', port: port });\n        return connect.call(this, options, callback);\n      }\n    }\n    return connect.apply(this, arguments);\n  };\n}\n\n// source - Hostname or host:port (default to port 80)\n// target - Target port number\nmodule.exports = function addRoute(source, target) {\n  assert(source, 'Expected source address of the form \"host:port\" or just \"host\"');\n  var sourceHost = source.split(':')[0];\n  var sourcePort = source.split(':')[1] || 80;\n  var route = routing.get(sourceHost) || {};\n  routing.set(sourceHost, route);\n  if (!route[sourcePort]) route[sourcePort] = target;\n  assert(route[sourcePort] === target, 'Already have routing from ' + source + ' to ' + route[sourcePort]);\n\n  // Enable Socket.connect routing\n  enableRerouting();\n};\n//# sourceMappingURL=reroute.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/lib/storage.js":"// See [Web Storage](http://dev.w3.org/html5/webstorage/)\n'use strict';\n\nvar _get = require('babel-runtime/helpers/get')['default'];\n\nvar _inherits = require('babel-runtime/helpers/inherits')['default'];\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];\n\nvar _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];\n\nvar _Map = require('babel-runtime/core-js/map')['default'];\n\nvar _getIterator = require('babel-runtime/core-js/get-iterator')['default'];\n\nvar _Object$defineProperties = require('babel-runtime/core-js/object/define-properties')['default'];\n\nvar DOM = require('./dom');\n\n// Implementation of the StorageEvent.\n\nvar StorageEvent = (function (_DOM$Event) {\n  _inherits(StorageEvent, _DOM$Event);\n\n  function StorageEvent(storage, url, key, oldValue, newValue) {\n    _classCallCheck(this, StorageEvent);\n\n    _get(Object.getPrototypeOf(StorageEvent.prototype), 'constructor', this).call(this, 'storage');\n    this._storage = storage;\n    this._url = url;\n    this._key = key;\n    this._oldValue = oldValue;\n    this._newValue = newValue;\n  }\n\n  // Storage area. The storage area is shared by multiple documents of the same\n  // origin. For session storage, they must also share the same browsing context.\n\n  _createClass(StorageEvent, [{\n    key: 'url',\n    get: function get() {\n      return this._url;\n    }\n  }, {\n    key: 'storageArea',\n    get: function get() {\n      return this._storage;\n    }\n  }, {\n    key: 'key',\n    get: function get() {\n      return this._key;\n    }\n  }, {\n    key: 'oldValue',\n    get: function get() {\n      return this._oldValue;\n    }\n  }, {\n    key: 'newValue',\n    get: function get() {\n      return this._newValue;\n    }\n  }]);\n\n  return StorageEvent;\n})(DOM.Event);\n\nvar StorageArea = (function () {\n  function StorageArea() {\n    _classCallCheck(this, StorageArea);\n\n    this._items = new _Map();\n    this._storages = [];\n  }\n\n  // Implementation of the Storage interface, used by local and session storage.\n\n  // Fire a storage event. Fire in all documents that share this storage area,\n  // except for the source document.\n\n  _createClass(StorageArea, [{\n    key: '_fire',\n    value: function _fire(source, key, oldValue, newValue) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(this._storages), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2);\n\n          var storage = _step$value[0];\n          var _window = _step$value[1];\n\n          if (storage === source) continue;\n          var _event = new StorageEvent(storage, _window.location.href, key, oldValue, newValue);\n          _window.dispatchEvent(_event);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    // Return number of key/value pairs.\n  }, {\n    key: 'key',\n\n    // Get key by ordinal position.\n    value: function key(index) {\n      var iterator = this._items.keys();\n      var next = iterator.next();\n      for (var i = 0; i < index; ++i) {\n        next = iterator.next();\n      }return next.value;\n    }\n\n    // Get value from key\n  }, {\n    key: 'get',\n    value: function get(key) {\n      return this._items.has(key) ? this._items.get(key) : null;\n    }\n\n    // Set the value of a key. We also need the source storage (so we don't send\n    // it a storage event).\n  }, {\n    key: 'set',\n    value: function set(source, key, value) {\n      var oldValue = this._items.get(key);\n      this._items.set(key, value);\n      this._fire(source, key, oldValue, value);\n    }\n\n    // Remove the value at the key. We also need source storage (see set above).\n  }, {\n    key: 'remove',\n    value: function remove(source, key) {\n      var oldValue = this._items.get(key);\n      this._items['delete'](key);\n      this._fire(source, key, oldValue);\n    }\n\n    // Remove all values. We also need source storage (see set above).\n  }, {\n    key: 'clear',\n    value: function clear(source) {\n      this._items.clear();\n      this._fire(source);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._items.toString();\n    }\n\n    // Associate local/sessionStorage and window with this storage area. Used when firing events.\n  }, {\n    key: 'associate',\n    value: function associate(storage, window) {\n      this._storages.push([storage, window]);\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      return this._items.size;\n    }\n  }, {\n    key: 'pairs',\n    get: function get() {\n      return [].concat(_toConsumableArray(this._items));\n    }\n  }]);\n\n  return StorageArea;\n})();\n\nvar Storage = (function () {\n  function Storage(area) {\n    _classCallCheck(this, Storage);\n\n    this._area = area;\n  }\n\n  // Combined local/session storage.\n\n  // ### storage.length => Number\n  //\n  // Returns the number of key/value pairs in this storage.\n\n  _createClass(Storage, [{\n    key: 'key',\n\n    // ### storage.key(index) => String\n    //\n    // Returns the key at this position.\n    value: function key(index) {\n      return this._area.key(index);\n    }\n\n    // ### storage.getItem(key) => Object\n    //\n    // Returns item by key.\n  }, {\n    key: 'getItem',\n    value: function getItem(key) {\n      return this._area.get(key.toString());\n    }\n\n    // ### storage.setItem(key, Object)\n    //\n    // Add item or change value of existing item.\n  }, {\n    key: 'setItem',\n    value: function setItem(key, value) {\n      this._area.set(this, key.toString(), value);\n    }\n\n    // ### storage.removeItem(key)\n    //\n    // Remove item.\n  }, {\n    key: 'removeItem',\n    value: function removeItem(key) {\n      this._area.remove(this, key.toString());\n    }\n\n    // ### storage.clear()\n    //\n    // Remove all items.\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this._area.clear(this);\n    }\n\n    // Dump to a string, useful for debugging.\n  }, {\n    key: 'dump',\n    value: function dump() {\n      var output = arguments.length <= 0 || arguments[0] === undefined ? process.stdout : arguments[0];\n\n      return this._area.dump(output);\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      return this._area.length;\n    }\n  }]);\n\n  return Storage;\n})();\n\nvar Storages = (function () {\n  function Storages() {\n    _classCallCheck(this, Storages);\n\n    this._locals = new _Map();\n    this._sessions = new _Map();\n  }\n\n  // Return local Storage based on the document origin (hostname/port).\n\n  _createClass(Storages, [{\n    key: 'local',\n    value: function local(host) {\n      if (!this._locals.has(host)) this._locals.set(host, new StorageArea());\n      return new Storage(this._locals.get(host));\n    }\n\n    // Return session Storage based on the document origin (hostname/port).\n  }, {\n    key: 'session',\n    value: function session(host) {\n      if (!this._sessions.has(host)) this._sessions.set(host, new StorageArea());\n      return new Storage(this._sessions.get(host));\n    }\n\n    // Extend window with local/session storage support.\n  }, {\n    key: 'extend',\n    value: function extend(window) {\n      var storages = this;\n      window.StorageEvent = StorageEvent;\n      _Object$defineProperties(window, {\n        localStorage: {\n          get: function get() {\n            var document = this.document;\n\n            if (!document._localStorage) document._localStorage = storages.local(document.location.host);\n            return document._localStorage;\n          }\n        },\n\n        sessionStorage: {\n          get: function get() {\n            var document = this.document;\n\n            if (!document._sessionStorage) document._sessionStorage = storages.session(document.location.host);\n            return document._sessionStorage;\n          }\n        }\n      });\n    }\n\n    // Used to dump state to console (debuggin)\n  }, {\n    key: 'dump',\n    value: function dump() {\n      var output = arguments.length <= 0 || arguments[0] === undefined ? process.stdout : arguments[0];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = _getIterator(this._locals), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = _slicedToArray(_step2.value, 2);\n\n          var domain = _step2$value[0];\n          var area = _step2$value[1];\n\n          output.write(domain + ' local:\\n');\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = _getIterator(area.pairs), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var _step4$value = _slicedToArray(_step4.value, 2);\n\n              var _name = _step4$value[0];\n              var value = _step4$value[1];\n\n              output.write('  ' + _name + ' = ' + value + '\\n');\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4['return']) {\n                _iterator4['return']();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n            _iterator2['return']();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = _getIterator(this._sessions), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _step3$value = _slicedToArray(_step3.value, 2);\n\n          var domain = _step3$value[0];\n          var area = _step3$value[1];\n\n          output.push(domain + ' session:\\n');\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = _getIterator(area.pairs), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var _step5$value = _slicedToArray(_step5.value, 2);\n\n              var _name2 = _step5$value[0];\n              var value = _step5$value[1];\n\n              output.write('  ' + _name2 + ' = ' + value + '\\n');\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5['return']) {\n                _iterator5['return']();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3['return']) {\n            _iterator3['return']();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n\n    // browser.saveStorage uses this\n  }, {\n    key: 'save',\n    value: function save() {\n      var serialized = ['# Saved on ' + new Date().toISOString()];\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = _getIterator(this._locals), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _step6$value = _slicedToArray(_step6.value, 2);\n\n          var domain = _step6$value[0];\n          var area = _step6$value[1];\n\n          var pairs = area.pairs;\n          if (pairs.length) {\n            serialized.push(domain + ' local:');\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n              for (var _iterator8 = _getIterator(area.pairs), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                var _step8$value = _slicedToArray(_step8.value, 2);\n\n                var _name3 = _step8$value[0];\n                var value = _step8$value[1];\n\n                serialized.push('  ' + escape(_name3) + ' = ' + escape(value));\n              }\n            } catch (err) {\n              _didIteratorError8 = true;\n              _iteratorError8 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion8 && _iterator8['return']) {\n                  _iterator8['return']();\n                }\n              } finally {\n                if (_didIteratorError8) {\n                  throw _iteratorError8;\n                }\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6['return']) {\n            _iterator6['return']();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = _getIterator(this._sessions), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var _step7$value = _slicedToArray(_step7.value, 2);\n\n          var domain = _step7$value[0];\n          var area = _step7$value[1];\n\n          var pairs = area.pairs;\n          if (pairs.length) {\n            serialized.push(domain + ' session:');\n            var _iteratorNormalCompletion9 = true;\n            var _didIteratorError9 = false;\n            var _iteratorError9 = undefined;\n\n            try {\n              for (var _iterator9 = _getIterator(area.pairs), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                var _step9$value = _slicedToArray(_step9.value, 2);\n\n                var _name4 = _step9$value[0];\n                var value = _step9$value[1];\n\n                serialized.push('  ' + escape(_name4) + ' = ' + escape(value));\n              }\n            } catch (err) {\n              _didIteratorError9 = true;\n              _iteratorError9 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion9 && _iterator9['return']) {\n                  _iterator9['return']();\n                }\n              } finally {\n                if (_didIteratorError9) {\n                  throw _iteratorError9;\n                }\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7['return']) {\n            _iterator7['return']();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return serialized.join('\\n') + '\\n';\n    }\n\n    // browser.loadStorage uses this\n  }, {\n    key: 'load',\n    value: function load(serialized) {\n      var storage = null;\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = _getIterator(serialized.split(/\\n+/)), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var item = _step10.value;\n\n          if (item[0] === '#' || item === '') continue;\n          if (item[0] === ' ') {\n            var _item$split = item.split('=');\n\n            var _item$split2 = _slicedToArray(_item$split, 2);\n\n            var key = _item$split2[0];\n            var value = _item$split2[1];\n\n            if (storage) storage.setItem(unescape(key.trim()), unescape(value.trim()));else throw new Error('Must specify storage type using local: or session:');\n          } else {\n            var _item$split3 = item.split(' ');\n\n            var _item$split32 = _slicedToArray(_item$split3, 2);\n\n            var domain = _item$split32[0];\n            var type = _item$split32[1];\n\n            if (type === 'local:') storage = this.local(domain);else if (type === 'session:') storage = this.session(domain);else throw new Error('Unkown storage type ' + type);\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10['return']) {\n            _iterator10['return']();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Storages;\n})();\n\nmodule.exports = Storages;\n//# sourceMappingURL=storage.js.map\n","/home/travis/build/npmtest/node-npmtest-zombie/node_modules/zombie/Gulpfile.js":"const assert      = require('assert');\nconst del         = require('del');\nconst eslint      = require('gulp-eslint');\nconst exec        = require('gulp-exec');\nconst File        = require('fs');\nconst gulp        = require('gulp');\nconst gutil       = require('gulp-util');\nconst notify      = require('gulp-notify');\nconst sourcemaps  = require('gulp-sourcemaps');\nconst babel       = require('gulp-babel');\n\n\n// gulp -> gulp watch\ngulp.task('default', ['watch']);\n\n\n// gulp lint -> errors if code dirty\ngulp.task('lint', function () {\n  return gulp.src([ 'js/**/*.js', 'test/*.js' ])\n    .pipe(eslint())\n    .pipe(eslint.formatEach())\n    .pipe(eslint.failOnError());\n});\n\n\n// gulp build -> compile coffee script\ngulp.task('build', ['clean'], function() {\n  return gulp.src('src/**/*.js')\n    .pipe(sourcemaps.init())\n    .pipe(babel())\n    .pipe(sourcemaps.write('.'))\n    .pipe(gulp.dest('lib'))\n    .pipe(notify({\n      message: 'Zombie: built!',\n      onLast:  true\n    }));\n});\n\n\n// gulp clean -> clean generated files\ngulp.task('clean', function() {\n  return del('lib/**');\n});\n\n\n// gulp watch -> watch for changes and compile\ngulp.task('watch', ['build'], function() {\n  return gulp.watch('src/*.js', ['clean', 'build']);\n});\n\n\n// gulp tag -> Tag this release\ngulp.task('tag', ['changes'], function() {\n  const version = require('./package.json').version;\n  const tag     = 'v' + version;\n\n  gutil.log('Tagging this release', tag);\n  return gulp.src('.changes')\n    .pipe( exec('git add package.json CHANGELOG.md') )\n    .pipe( exec('git commit --allow-empty -m \"Version ' + version + '\"') )\n    .pipe( exec('git tag ' + tag + ' --file .changes') )\n    .pipe( exec('git push origin ' + tag) )\n    .pipe( exec('git push origin master') );\n});\n\n// Generate a change log summary for this release\n// git tag uses the generated .changes file\ngulp.task('changes', function() {\n  const version   = require('./package.json').version;\n  const changelog = File.readFileSync('CHANGELOG.md', 'utf-8');\n  const match     = changelog.match(/^## Version (.*) .*\\n([\\S\\s]+?)\\n##/m);\n\n  assert(match, 'CHANGELOG.md missing entry: ## Version ' + version);\n  assert.equal(match[1], version, 'CHANGELOG.md missing entry for version ' + version);\n\n  const changes   = match[2].trim();\n  assert(changes, 'CHANGELOG.md empty entry for version ' + version);\n  File.writeFileSync('.changes', changes);\n});\n\n"}